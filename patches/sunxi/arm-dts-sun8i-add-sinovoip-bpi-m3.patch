Added files

diff --git a/arch/arm/boot/dts/sun8i-a83t-sinovoip-bpi-m3.dts b/arch/arm/boot/dts/sun8i-a83t-sinovoip-bpi-m3.dts
new file mode 100644
index 0000000..fb52142
--- /dev/null
+++ b/arch/arm/boot/dts/sun8i-a83t-sinovoip-bpi-m3.dts
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2016 Vishnu Patekar
+ * Vishnu Patekar <vishnupatekar0510@gmail.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+#include "sun8i-a83t.dtsi"
+#include "sunxi-common-regulators.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/pinctrl/sun4i-a10.h>
+
+/ {
+	model = "Sinovoip BananaPi M3 v1.2";
+	compatible = "sinovoip,bpi-m3", "allwinner,sun8i-a83t";
+
+	aliases {
+		serial0 = &uart0;
+		lcd1 = &lcd1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	mmc1_pwrseq: mmc1_pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_pwrseq_pin_bpi_m3>;
+//fixme
+		reset-gpios = <&r_pio 0 2 GPIO_ACTIVE_LOW>; /* PL2 WIFI_EN */
+	};
+};
+
+&ccu {
+	/* force some rates */
+	assigned-clocks = <&ccu CLK_PLL_PERIPH>,
+			<&ccu CLK_PLL_VE>,
+			<&ccu CLK_PLL_GPU>,
+			<&ccu CLK_PLL_HSIC>,
+			<&ccu CLK_PLL_VIDEO1>;
+	assigned-clock-rates =	<1200000000>,	// pll_periph
+				<432000000>,	// pll_ve
+				<432000000>,	// pll_gpu
+				<480000000>,	// pll_hsic
+				<297000000>;	// pll_video1
+};
+
+&ehci0 {
+	/* Terminus Tech FE 1.1s 4-port USB 2.0 hub here */
+	status = "okay";
+
+	/* TODO GL830 USB-to-SATA bridge downstream w/ GPIO power controls */
+};
+
+&mmc0 {						// SD card
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc0_pins_a>, <&mmc0_cd_pin>;
+	vmmc-supply = <&reg_vcc3v3>;
+	cd-gpios = <&pio 5 6 GPIO_ACTIVE_HIGH>; /* PF6 */
+	bus-width = <4>;
+	cd-inverted;
+	status = "okay";
+};
+
+// copy from Bananapi M2+ (wens)
+&mmc1 {						// wifi/BT
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins_a>;
+//fixme: no power/regulator, but needed in the mmc driver
+	vmmc-supply = <&reg_vcc3v3>;
+	mmc-pwrseq = <&mmc1_pwrseq>;
+//fixme: live: bus width = 3 (8 bits)
+//fixme: .fex:
+// wl_reg_on PL2 1
+// wl_host_wake PL3 4
+	bus-width = <4>;
+	non-removable;
+//fixme: added 16-06-23
+	enable-wakeup;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+		interrupt-parent = <&r_pio>;
+//fixme: live: irq 3 (absolute) - doc hard wake-ap = PL3
+		interrupts = <0 3 IRQ_TYPE_LEVEL_LOW>; /* PL3 */
+		interrupt-names = "host-wake";
+	};
+};
+
+&mmc2 {					// eMMC
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc2_8bit_pins>;
+	vmmc-supply = <&reg_vcc3v3>;
+	vqmmc-supply = <&reg_vcc3v3>;
+	bus-width = <8>;
+	non-removable;
+//wens - not added - back 16-06-13
+	cap-mmc-hw-reset;
+//	mmc-ddr-1_8v;		set by default
+	status = "okay";
+};
+
+&r_pio {
+	mmc1_pwrseq_pin_bpi_m3: mmc1_pwrseq_pin@0 {
+		allwinner,pins = "PL2";
+		allwinner,function = "gpio_out";
+		allwinner,drive = <SUN4I_PINCTRL_10_MA>;
+		allwinner,pull = <SUN4I_PINCTRL_NO_PULL>;
+	};
+};
+
+&r_rsb {
+	status = "okay";
+};
+
+&reg_usb1_vbus {
+	gpio = <&pio 3 24 GPIO_ACTIVE_HIGH>; /* PD24 */
+	status = "okay";
+};
+
+&reg_vcc3v0 {
+	status = "disabled";
+};
+
+&reg_vcc5v0 {
+	status = "disabled";
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins_b>;
+	status = "okay";
+};
+
+&usbphy {
+	usb1_vbus-supply = <&reg_usb1_vbus>;
+	status = "okay";
+};
+
+&usb_otg {
+	/* VBUS detection/drive support in PMIC required for OTG */
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usb1_vbus_pin_a {
+	allwinner,pins = "PD24";
+};
+
+&de {
+	status = "okay";
+};
+
+&lcd1 {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&i2s2 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/sun8i-h3-sinovoip-bpi-m2-plus.dts b/arch/arm/boot/dts/sun8i-h3-sinovoip-bpi-m2-plus.dts
new file mode 100644
index 0000000..f04d53c
--- /dev/null
+++ b/arch/arm/boot/dts/sun8i-h3-sinovoip-bpi-m2-plus.dts
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2016 Chen-Yu Tsai <wens@csie.org>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+#include "sun8i-h3.dtsi"
+#include "sunxi-common-regulators.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/pinctrl/sun4i-a10.h>
+
+/ {
+	model = "Sinovoip BPI-M2+";
+	compatible = "sinovoip,bpi-m2+", "allwinner,sun8i-h3";
+
+	aliases {
+		serial0 = &uart0;
+		serial1 = &uart1;
+		lcd0 = &lcd0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwr_led_bpi_m2p>;
+
+		pwr_led {
+			label = "bpi-m2+:red:pwr";
+			gpios = <&r_pio 0 10 GPIO_ACTIVE_HIGH>; /* PL10 */
+			default-state = "on";
+		};
+	};
+
+	gpio_keys {
+		compatible = "gpio-keys";
+		pinctrl-names = "default";
+		pinctrl-0 = <&sw_r_bpi_m2p>;
+
+		sw4 {
+			label = "power";
+			linux,code = <BTN_0>;
+			gpios = <&r_pio 0 3 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	wifi_pwrseq: wifi_pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_en_bpi_m2p>;
+		reset-gpios = <&r_pio 0 7 GPIO_ACTIVE_LOW>; /* PL7 */
+	};
+};
+
+&ccu {
+	/* force some rates and parents */
+	assigned-clocks = <&ccu CLK_PLL_PERIPH0>,
+			  <&ccu CLK_PLL_PERIPH1>,
+			  <&ccu CLK_PLL_DE>,
+			  <&ccu CLK_I2S0>,
+			  <&ccu CLK_I2S1>,
+			  <&ccu CLK_I2S2>;
+//			  <&ccu CLK_DE>;
+	assigned-clock-parents = <0>,
+				<0>,
+				<0>,
+				<&ccu CLK_PLL_AUDIO>,
+				<&ccu CLK_PLL_AUDIO>,
+				<&ccu CLK_PLL_AUDIO>;
+//				<&ccu CLK_PLL_DE>;
+	assigned-clock-rates = <600000000>,
+				<600000000>,
+				<864000000>,
+				<0>,
+				<0>,
+				<0>;
+//				<0>;
+};
+
+&de {
+	status = "okay";
+};
+
+&ehci1 {
+	status = "okay";
+};
+
+&ehci2 {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&i2s2 {
+	status = "okay";
+};
+
+#if 0
+&ir {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ir_pins_a>;
+	status = "okay";
+};
+#endif
+
+&lcd0 {
+	status = "okay";
+};
+
+&mmc0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc0_pins_a>, <&mmc0_cd_pin>;
+	vmmc-supply = <&reg_vcc3v3>;
+	bus-width = <4>;
+	cd-gpios = <&pio 5 6 GPIO_ACTIVE_HIGH>; /* PF6 */
+	cd-inverted;
+	status = "okay";
+};
+
+&mmc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins_a>;
+	vmmc-supply = <&reg_vcc3v3>;
+	vqmmc-supply = <&reg_vcc3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	bus-width = <4>;
+	non-removable;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+		interrupt-parent = <&pio>;
+		interrupts = <6 10 IRQ_TYPE_LEVEL_LOW>; /* PG10 / EINT10 */
+		interrupt-names = "host-wake";
+	};
+};
+
+&mmc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc2_8bit_pins>;
+	vmmc-supply = <&reg_vcc3v3>;
+	vqmmc-supply = <&reg_vcc3v3>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&ohci1 {
+	status = "okay";
+};
+
+&ohci2 {
+	status = "okay";
+};
+
+&r_pio {
+	pwr_led_bpi_m2p: led_pins@0 {
+		allwinner,pins = "PL10";
+		allwinner,function = "gpio_out";
+		allwinner,drive = <SUN4I_PINCTRL_10_MA>;
+		allwinner,pull = <SUN4I_PINCTRL_NO_PULL>;
+	};
+
+	sw_r_bpi_m2p: key_pins@0 {
+		allwinner,pins = "PL3";
+		allwinner,function = "gpio_in";
+		allwinner,drive = <SUN4I_PINCTRL_10_MA>;
+		allwinner,pull = <SUN4I_PINCTRL_NO_PULL>;
+	};
+
+	wifi_en_bpi_m2p: wifi_en_pin {
+		allwinner,pins = "PL7";
+		allwinner,function = "gpio_out";
+		allwinner,drive = <SUN4I_PINCTRL_10_MA>;
+		allwinner,pull = <SUN4I_PINCTRL_NO_PULL>;
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins_a>;
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_pins_a>;
+	status = "okay";
+};
+
+&usbphy {
+	/* USB VBUS is on as long as VCC-IO is on */
+	status = "okay";
+};
diff --git a/drivers/clk/sunxi/Kconfig b/drivers/clk/sunxi/Kconfig
new file mode 100644
index 0000000..1101494
--- /dev/null
+++ b/drivers/clk/sunxi/Kconfig
@@ -0,0 +1,6 @@
+config CLK_SUN8I_APB0
+	def_bool MACH_SUN9I || MACH_SUN8I
+ 
+config CLK_SUN9I_CPUS
+	def_bool MACH_SUN9I || MACH_SUN8I
+
diff --git a/drivers/clk/sunxi/ccu.c b/drivers/clk/sunxi/ccu.c
new file mode 100644
index 0000000..69261d7
--- /dev/null
+++ b/drivers/clk/sunxi/ccu.c
@@ -0,0 +1,1080 @@
+/*
+ * Allwinner system CCU
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Rewrite from 'sunxi-ng':
+ * Copyright (C) 2016 Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/reset-controller.h>
+#include <linux/iopoll.h>
+#include <linux/slab.h>
+#include <linux/rational.h>
+#include <linux/of_address.h>
+
+#include "ccu.h"
+
+#define CCU_DEBUG 1
+
+#if CCU_DEBUG
+#define ccu_dbg(fmt, ...) pr_info("*ccu* " fmt, ##__VA_ARGS__)
+#else
+#define ccu_dbg(fmt, ...)
+#endif
+
+#define CCU_MASK(shift, width) (((1 << width) - 1) << shift)
+
+/*
+ * factors:
+ *	n: multiplier (PLL)
+ *	d1, d2: boolean dividers by 2 (d2 is p with 1 bit width - PLL)
+ *	k: multiplier (PLL)
+ *	m: divider
+ *	p: divider by power of 2
+ */
+struct val_pll {
+	int n, d1, k, m, p;
+};
+struct val_periph {
+	int m, p;
+};
+
+static DEFINE_SPINLOCK(ccu_lock);
+
+void ccu_set_field(struct ccu *ccu, int reg, u32 mask, u32 val)
+{
+	ccu_dbg("%s set %03x %08x\n",
+		clk_hw_get_name(&ccu->hw), reg,
+		(readl(ccu->base + reg) & ~mask) | val);
+
+	spin_lock(&ccu_lock);
+	writel((readl(ccu->base + reg) & ~mask) | val, ccu->base + reg);
+	spin_unlock(&ccu_lock);
+}
+
+/* --- enable / disable --- */
+static int ccu_enable(struct clk_hw *hw)
+{
+	struct ccu *ccu = hw2ccu(hw);
+
+	ccu_dbg("%s enable\n", clk_hw_get_name(&ccu->hw));
+
+	if (ccu->reset_reg)
+		ccu_set_field(ccu, ccu->reset_reg, BIT(ccu->reset_bit),
+						BIT(ccu->reset_bit));
+	if (ccu->bus_reg)
+		ccu_set_field(ccu, ccu->bus_reg, BIT(ccu->bus_bit),
+						BIT(ccu->bus_bit));
+	if (ccu->has_gate)
+		ccu_set_field(ccu, ccu->reg, BIT(ccu->gate_bit),
+						BIT(ccu->gate_bit));
+
+	return 0;
+}
+
+void ccu_disable(struct clk_hw *hw)
+{
+	struct ccu *ccu = hw2ccu(hw);
+
+	ccu_dbg("%s disable\n", clk_hw_get_name(&ccu->hw));
+
+	if (ccu->has_gate)
+		ccu_set_field(ccu, ccu->reg, BIT(ccu->gate_bit), 0);
+	if (ccu->bus_reg)
+		ccu_set_field(ccu, ccu->bus_reg, BIT(ccu->bus_bit), 0);
+	if (ccu->reset_reg)
+		ccu_set_field(ccu, ccu->reset_reg, BIT(ccu->reset_bit), 0);
+}
+
+/* --- PLL --- */
+static void ccu_wait_pll_stable(struct ccu *ccu)
+{
+	u32 lock, reg;
+
+	if (ccu->lock_reg) {
+		lock = BIT(ccu->lock_bit);
+		WARN_ON(readl_relaxed_poll_timeout(ccu->base + ccu->lock_reg,
+							reg, !(reg & lock),
+							100, 70000));
+	} else {
+//		udelay(500);
+		usleep_range(500, 700);
+	}
+}
+
+static unsigned long ccu_pll_find_best(struct ccu *ccu,
+					unsigned long rate,
+					unsigned long parent_rate,
+					struct val_pll *p_v)
+{
+	long new_rate, best_rate = 0;
+	long delta, best_delta = 1000000;
+	unsigned long lmul, ldiv;
+	int n, k, m, p, tmp;
+	int n_max = 1 << ccu->n_width;
+	int d1_max = 1 << ccu->d1_width;
+	int k_max = 1 << ccu->k_width;
+	int m_max = 1 << ccu->m_width;
+	int p_max = (1 << ccu->p_width) - 1;
+
+	/* set the default values */
+	p_v->d1 = 1;
+	p_v->m = 1;
+	p_v->k = 1;
+	p_v->p = 0;
+
+	if (ccu->features & CCU_FEATURE_N0)
+		n_max--;
+
+	/* no divider: parent_rate * n * k */
+	if (d1_max == 1 && m_max == 1 && p_max == 0) {
+		for (k = k_max; k > 0; k--) {
+			int mul;
+
+			mul = rate / parent_rate / k;
+			for (n = mul; n <= mul + 1; n++) {
+				if (n < ccu->n_min)
+					continue;
+				if (n > n_max)
+					break;
+				new_rate = parent_rate * n * k;
+				delta = rate - new_rate;
+				if (delta == 0) {
+					p_v->n = n;
+					p_v->k = k;
+					return new_rate;
+				}
+				if (delta < 0)
+					delta = -delta;
+				if (delta < best_delta) {
+					best_delta = delta;
+					best_rate = new_rate;
+					p_v->n = n;
+					p_v->k = k;
+				}
+			}
+		}
+		return best_rate;
+	}
+
+	/* only one multiplier: parent_rate / d1 * n / m >> p */
+	if (k_max == 1) {
+		for (p = 0; p <= p_max + d1_max - 1; p++) {
+			if (m_max > 1) {
+				rational_best_approximation(rate, parent_rate,
+							n_max - 1,
+							m_max - 1,
+							&lmul, &ldiv);
+				if (ldiv == 0)
+					continue;
+				n = lmul;
+				m = ldiv;
+			} else {
+				n = rate / (parent_rate >> p);
+				if (n > n_max)
+					continue;
+				m = 1;
+			}
+			if (n < ccu->n_min) {
+				tmp = (ccu->n_min + n - 1) / n;
+				n *= tmp;
+				m *= tmp;
+				if (n > n_max || m > m_max)
+					continue;
+			}
+			new_rate = parent_rate * n / m >> p;
+			delta = rate - new_rate;
+			if (delta == 0) {
+				if (p > 1 && d1_max > 1) {
+					p--;
+					p_v->d1 = 2;
+				} else {
+					p_v->d1 = 1;
+				}
+				p_v->n = n;
+				p_v->m = m;
+				p_v->p = p;
+				return new_rate;
+			}
+			if (delta < 0)
+				delta = -delta;
+			if (delta < best_delta) {
+				best_delta = delta;
+				best_rate = new_rate;
+				p_v->n = n;
+				p_v->m = m;
+				if (p > 1 && d1_max > 1) {
+					p--;
+					p_v->d1 = 2;
+				} else {
+					p_v->d1 = 1;
+				}
+				p_v->p = p;
+			}
+		}
+		return best_rate;
+	}
+
+	/* general case: parent * n / m * k >> p */
+	for (p = 0; p <= p_max; p++) {
+		for (k = k_max; k > 0; k--) {
+			if (m_max > 1) {
+				rational_best_approximation(rate, parent_rate,
+							n_max - 1,
+							m_max - 1,
+							&lmul, &ldiv);
+				if (ldiv == 0)
+					continue;
+				n = lmul;
+				m = ldiv;
+			} else {
+				n = rate / k / (parent_rate >> p);
+				if (n > n_max)
+					continue;
+				m = 1;
+			}
+			if (n < ccu->n_min) {
+				tmp = (ccu->n_min + n - 1) / n;
+				n *= tmp;
+				m *= tmp;
+				if (n > n_max || m > m_max)
+					continue;
+			}
+			new_rate = parent_rate * n / m * k >> p;
+			delta = rate - new_rate;
+			if (delta == 0) {
+				rational_best_approximation(k, m,
+						k_max - 1,
+						m_max - 1,
+						&lmul, &ldiv);
+				p_v->n = n;
+				p_v->m = ldiv;
+				p_v->k = lmul;
+				p_v->p = p;
+				return new_rate;
+			}
+			if (delta < 0)
+				delta = -delta;
+			if (delta < best_delta) {
+				best_delta = delta;
+				best_rate = new_rate;
+				p_v->n = n;
+				p_v->m = m;
+				p_v->k = k;
+				p_v->p = p;
+			}
+		}
+	}
+	return best_rate;
+}
+
+static unsigned long ccu_pll_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	const struct ccu_extra *extra = ccu->extra;
+	unsigned long rate;
+	int i, n, d1, m, k, p;
+	u32 reg;
+
+	reg = readl(ccu->base + ccu->reg);
+
+	if (extra) {
+		for (i = 0; i < extra->num_frac - 1; i++) {
+			if ((reg & extra->frac[i].mask) == extra->frac[i].val)
+				return rate = extra->frac[i].rate;
+		}
+	}
+
+	rate = parent_rate;
+
+	if (ccu->d1_width) {
+		d1 = reg >> ccu->d1_shift;
+		d1 &= (1 << ccu->d1_width) - 1;
+		rate /= (d1 + 1);
+	}
+
+	if (ccu->n_width) {
+		n = reg >> ccu->n_shift;
+		n &= (1 << ccu->n_width) - 1;
+		if (!(ccu->features & CCU_FEATURE_N0))
+			n++;
+		rate *= n;
+	}
+
+	if (ccu->m_width) {
+		m = reg >> ccu->m_shift;
+		m &= (1 << ccu->m_width) - 1;
+		rate /= (m + 1);
+	}
+
+	if (ccu->k_width) {
+		k = reg >> ccu->k_shift;
+		k &= (1 << ccu->k_width) - 1;
+		rate *= (k + 1);
+	}
+
+	if (ccu->p_width) {
+		p = reg >> ccu->p_shift;
+		p &= (1 << ccu->p_width) - 1;
+		rate >>= p;
+	}
+
+	if (extra && (ccu->features & CCU_FEATURE_FIXED_POSTDIV))
+		rate /= extra->fixed_div[0];
+
+	return rate;
+}
+
+static int ccu_pll_determine_rate(struct clk_hw *hw,
+				struct clk_rate_request *req)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	const struct ccu_extra *extra = ccu->extra;
+	unsigned long rate = req->rate;
+	unsigned long parent_rate = req->best_parent_rate;
+	struct val_pll v;
+	int i;
+
+	if (extra) {
+		for (i = 0; i < extra->num_frac - 1; i++) {
+			if (extra->frac[i].rate == rate)
+				return rate;
+		}
+
+		if (ccu->features & CCU_FEATURE_FIXED_POSTDIV)
+			rate *= extra->fixed_div[0];
+	}
+
+	rate = ccu_pll_find_best(ccu, rate, parent_rate, &v);
+
+	if (extra && (ccu->features & CCU_FEATURE_FIXED_POSTDIV))
+		rate /= extra->fixed_div[0];
+
+	req->rate = rate;
+
+	return 0;
+}
+
+static void ccu_pll_set_flat_factors(struct ccu *ccu, u32 mask, u32 val)
+{
+	u32 reg, m_val, p_val;
+	u32 m_mask = CCU_MASK(ccu->m_shift, ccu->m_width);
+	u32 p_mask = CCU_MASK(ccu->p_shift, ccu->p_width);
+
+	reg = readl(ccu->base + ccu->reg);
+	m_val = reg & m_mask;
+	p_val = reg & p_mask;
+
+	spin_lock(&ccu_lock);
+
+	/* increase p, then m */
+	if (ccu->p_width && p_val < (val & p_mask)) {
+		reg &= ~p_mask;
+		reg |= val & p_mask;
+		writel(reg, ccu->base + ccu->reg);
+		udelay(10);
+	}
+	if (ccu->m_width && m_val < (val & m_mask)) {
+		reg &= ~m_mask;
+		reg |= val & m_mask;
+		writel(reg, ccu->base + ccu->reg);
+		udelay(10);
+	}
+
+	/* set other factors */
+	reg &= ~(mask & ~(p_mask | m_mask));
+	reg |= val & ~(p_mask | m_mask);
+	writel(reg, ccu->base + ccu->reg);
+
+	/* decrease m */
+	if (ccu->m_width && m_val > (val & m_mask)) {
+		reg &= ~m_mask;
+		reg |= val & m_mask;
+		writel(reg, ccu->base + ccu->reg);
+		udelay(10);
+	}
+
+	/* wait for PLL stable */
+	ccu_wait_pll_stable(ccu);
+
+	/* decrease p */
+	if (ccu->p_width && p_val > (val & p_mask)) {
+		reg &= ~p_mask;
+		reg |= val & p_mask;
+		writel(reg, ccu->base + ccu->reg);
+		udelay(10);
+	}
+
+	spin_unlock(&ccu_lock);
+}
+
+static int ccu_pll_set_rate(struct clk_hw *hw,
+				unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	const struct ccu_extra *extra = ccu->extra;
+	struct val_pll v;
+	u32 mask, val;
+
+	mask =  CCU_MASK(ccu->n_shift, ccu->n_width) |
+		CCU_MASK(ccu->d1_shift, ccu->d1_width) |
+		CCU_MASK(ccu->k_shift, ccu->k_width) |
+		CCU_MASK(ccu->m_shift, ccu->m_width) |
+		CCU_MASK(ccu->p_shift, ccu->p_width);
+	val = 0;
+
+	if (extra && extra->num_frac) {
+		int i;
+
+		for (i = 0; i < extra->num_frac - 1; i++) {
+			if (extra->frac[i].rate == rate) {
+				ccu_set_field(ccu, ccu->reg,
+						extra->frac[i].mask,
+						extra->frac[i].val);
+				return 0;
+			}
+		}
+		mask |= extra->frac[i].mask;
+		val |= extra->frac[i].val;
+	}
+
+	if (extra && (ccu->features & CCU_FEATURE_FIXED_POSTDIV))
+		rate *= extra->fixed_div[0];
+
+
+	rate = ccu_pll_find_best(ccu, rate, parent_rate, &v);
+
+	if (!(ccu->features & CCU_FEATURE_N0))
+		v.n--;
+
+	val |=  (v.n << ccu->n_shift) |
+		((v.d1 - 1) << ccu->d1_shift) |
+		((v.k - 1) << ccu->k_shift) |
+		((v.m - 1) << ccu->m_shift) |
+		(v.p << ccu->p_shift);
+
+	if (ccu->upd_bit)			/* (upd_bit is never 0) */
+		val |= BIT(ccu->upd_bit);
+
+	if (ccu->features & CCU_FEATURE_FLAT_FACTORS) {
+		ccu_pll_set_flat_factors(ccu, mask, val);
+		return 0;
+	}
+	ccu_set_field(ccu, ccu->reg, mask, val);
+	ccu_wait_pll_stable(ccu);
+
+	return 0;
+}
+
+const struct clk_ops ccu_pll_ops = {
+	.enable		= ccu_enable,
+	.disable	= ccu_disable,
+/*	.is_enabled	= NULL;	(don't disable the clocks at startup time) */
+
+	.determine_rate	= ccu_pll_determine_rate,
+	.recalc_rate	= ccu_pll_recalc_rate,
+	.set_rate	= ccu_pll_set_rate,
+};
+
+/* --- mux parent --- */
+static u8 ccu_get_parent(struct clk_hw *hw)
+{
+	struct ccu *ccu = hw2ccu(hw);
+
+	if (!ccu->mux_width)
+		return 0;
+
+	return (readl(ccu->base + ccu->reg) >> ccu->mux_shift) &
+				((1 << ccu->mux_width) - 1);
+}
+
+static int ccu_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	u32 mask;
+
+	if (!ccu->mux_width)
+		return 0;
+
+	mask = CCU_MASK(ccu->mux_shift, ccu->mux_width);
+
+	ccu_set_field(ccu, ccu->reg, mask, index << ccu->mux_shift);
+
+	return 0;
+}
+
+/* --- mux --- */
+static void ccu_mux_adjust_parent_for_prediv(struct ccu *ccu,
+					     int parent_index,
+					     unsigned long *parent_rate)
+{
+	const struct ccu_extra *extra = ccu->extra;
+	int prediv = 1;
+	u32 reg;
+
+	if (!(extra &&
+	      (ccu->features & (CCU_FEATURE_MUX_FIXED_PREDIV |
+				CCU_FEATURE_MUX_VARIABLE_PREDIV))))
+		return;
+
+	reg = readl(ccu->base + ccu->reg);
+	if (parent_index < 0)
+		parent_index = (reg >> ccu->mux_shift) &
+					((1 << ccu->mux_width) - 1);
+
+	if (ccu->features & CCU_FEATURE_MUX_FIXED_PREDIV) {
+		if (parent_index < ARRAY_SIZE(extra->fixed_div))
+			prediv = extra->fixed_div[parent_index];
+	}
+
+	if (ccu->features & CCU_FEATURE_MUX_VARIABLE_PREDIV)
+		if (parent_index == extra->variable_prediv.index) {
+			u8 div;
+
+			div = reg >> extra->variable_prediv.shift;
+			div &= (1 << extra->variable_prediv.width) - 1;
+			prediv = div + 1;
+		}
+
+	*parent_rate /= prediv;
+}
+
+/* --- periph --- */
+static unsigned long ccu_p_best_rate(struct ccu *ccu,
+					unsigned long rate,
+					unsigned long parent_rate,
+					struct val_periph *p_v)
+{
+	int p;
+	int p_max = (1 << ccu->p_width) - 1;
+
+	p_v->m = 1;
+
+	for (p = p_max - 1; p >= 0 ; p--) {
+		if (parent_rate >> p > rate)
+			break;
+	}
+	p_v->p = ++p;
+
+	return parent_rate >> p;
+}
+
+static unsigned long ccu_mp_best_rate(struct ccu *ccu,
+					unsigned long rate,
+					unsigned long parent_rate,
+					struct val_periph *p_v)
+{
+	const struct ccu_extra *extra = ccu->extra;
+	unsigned long new_rate, best_rate = 0;
+	long delta, best_delta = 1000000;
+	unsigned int m_max = 1 << ccu->m_width;
+	unsigned int p_max = (1 << ccu->p_width) - 1;
+	int i, m, p, div;
+
+	p_v->m = 1;
+	p_v->p = 0;
+
+	if (extra && (ccu->features & CCU_FEATURE_M_TABLE)) {
+		for (i = 0; i < ARRAY_SIZE(extra->m_table); i++) {
+			m = extra->m_table[i];
+			if (m == 0)
+				break;
+			for (p = p_max; p >= 0; p--) {
+				new_rate = parent_rate / m >> p;
+				delta = rate - new_rate;
+				if (delta == 0) {
+					p_v->m = i + 1;
+					p_v->p = p;
+					return new_rate;
+				}
+				if (delta < 0)
+					delta = -delta;
+				if (delta < best_delta) {
+					best_delta = delta;
+					best_rate = new_rate;
+					p_v->m = i + 1;
+					p_v->p = p;
+				}
+			}
+		}
+
+		return best_rate;
+	}
+
+	for (p = p_max; p >= 0; p--) {
+		div = parent_rate / rate >> p;
+		for (m = div; m <= div + 1; m++) {
+			if (m > m_max)
+				break;
+			new_rate = parent_rate / m >> p;
+			delta = rate - new_rate;
+			if (delta == 0) {
+				p_v->m = m;
+				p_v->p = p;
+				return new_rate;
+			}
+			if (delta < 0)
+				delta = -delta;
+			if (delta < best_delta) {
+				best_delta = delta;
+				best_rate = new_rate;
+				p_v->m = m;
+				p_v->p = p;
+			}
+		}
+	}
+
+	return best_rate;
+}
+
+static unsigned long ccu_periph_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	const struct ccu_extra *extra = ccu->extra;
+	int m, p;
+	u32 reg;
+
+	ccu_mux_adjust_parent_for_prediv(ccu, -1, &parent_rate);
+
+	if (!ccu->m_width && !ccu->p_width)
+		return parent_rate;
+
+	reg = readl(ccu->base + ccu->reg);
+	m = (reg >> ccu->m_shift) & ((1 << ccu->m_width) - 1);
+
+	if (extra && (ccu->features & CCU_FEATURE_M_TABLE))
+		m = extra->m_table[m] - 1;
+
+	if (!ccu->p_width)
+		return parent_rate / (m + 1);
+
+	reg = readl(ccu->base + ccu->reg);
+	p = (reg >> ccu->p_shift) & ((1 << ccu->p_width) - 1);
+
+	return parent_rate / (m + 1) >> p;
+}
+
+static int ccu_periph_determine_rate(struct clk_hw *hw,
+				struct clk_rate_request *req)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	unsigned long best_parent_rate = 0, best_rate = 0;
+	struct clk_hw *best_parent;
+	unsigned long (*round)(struct ccu *,
+				unsigned long,
+				unsigned long,
+				struct val_periph *p_v);
+	struct val_periph v;
+	unsigned int i;
+
+	if (ccu->m_width)
+		round = ccu_mp_best_rate;
+	else if (ccu->p_width)
+		round = ccu_p_best_rate;
+	else
+		return __clk_mux_determine_rate(hw, req);
+
+	for (i = 0; i < clk_hw_get_num_parents(hw); i++) {
+		unsigned long new_rate, parent_rate;
+		struct clk_hw *parent;
+
+		parent = clk_hw_get_parent_by_index(hw, i);
+		if (!parent)
+			continue;
+
+		parent_rate = clk_hw_get_rate(parent);
+		ccu_mux_adjust_parent_for_prediv(ccu, i, &parent_rate);
+		new_rate = round(ccu, req->rate, parent_rate, &v);
+
+		if (new_rate == req->rate) {
+			best_parent = parent;
+			best_parent_rate = parent_rate;
+			best_rate = new_rate;
+			goto out;
+		}
+
+		if ((req->rate - new_rate) < (req->rate - best_rate)) {
+			best_rate = new_rate;
+			best_parent_rate = parent_rate;
+			best_parent = parent;
+		}
+	}
+
+	if (best_rate == 0)
+		return -EINVAL;
+
+out:
+	req->best_parent_hw = best_parent;
+	req->best_parent_rate = best_parent_rate;
+	req->rate = best_rate;
+
+	return 0;
+}
+
+static int ccu_periph_set_rate(struct clk_hw *hw,
+				unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	const struct ccu_extra *extra = ccu->extra;
+	struct val_periph v;
+	u32 mask;
+
+	if (!ccu->m_width && !ccu->p_width)
+		return 0;
+
+	ccu_mux_adjust_parent_for_prediv(ccu, -1, &parent_rate);
+
+	if (extra && (ccu->features & CCU_FEATURE_MODE_SELECT)) {
+// mmc2: always time-out...
+#if 1 //test
+		/* fixme: should use new mode */
+		if (rate == extra->mode_select.rate)
+// clock too high? - test
+//			rate /= 2;
+			rate /= 4;	// 100MHz => 25MHz
+#else
+		mask = BIT(extra->mode_select.bit);
+		if (rate == extra->mode_select.rate) {
+			ccu_set_field(ccu, ccu->reg, mask, mask);
+//			rate *= 2;
+			rate /= 2;
+		} else {
+			ccu_set_field(ccu, ccu->reg, mask, 0);
+		}
+#endif
+	}
+
+	if (ccu->m_width)				/* m and p */
+		ccu_mp_best_rate(ccu, rate, parent_rate, &v);
+	else
+		ccu_p_best_rate(ccu, rate, parent_rate, &v);
+
+	mask = CCU_MASK(ccu->m_shift, ccu->m_width) |
+		CCU_MASK(ccu->p_shift, ccu->p_width);
+
+	if ((ccu->features & CCU_FEATURE_SET_RATE_GATE) &&
+	    ccu->has_gate)
+		ccu_set_field(ccu, ccu->reg, BIT(ccu->gate_bit), 0);
+	ccu_set_field(ccu, ccu->reg, mask, ((v.m - 1) << ccu->m_shift) |
+					    (v.p << ccu->p_shift));
+	if ((ccu->features & CCU_FEATURE_SET_RATE_GATE) &&
+	    ccu->has_gate)
+		ccu_set_field(ccu, ccu->reg, BIT(ccu->gate_bit),
+						BIT(ccu->gate_bit));
+
+	return 0;
+}
+
+const struct clk_ops ccu_periph_ops = {
+	.enable		= ccu_enable,
+	.disable	= ccu_disable,
+/*	.is_enabled	= NULL;	(don't disable the clocks at startup time) */
+
+	.get_parent	= ccu_get_parent,
+	.set_parent	= ccu_set_parent,
+
+	.determine_rate	= ccu_periph_determine_rate,
+	.recalc_rate	= ccu_periph_recalc_rate,
+	.set_rate	= ccu_periph_set_rate,
+};
+
+/* --- fixed factor --- */
+/* mul is n_width - div is m_width */
+unsigned long ccu_fixed_factor_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct ccu *ccu = hw2ccu(hw);
+
+	return parent_rate / ccu->m_width * ccu->n_width;
+}
+
+int ccu_fixed_factor_determine_rate(struct clk_hw *hw,
+				struct clk_rate_request *req)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	unsigned long *parent_rate = &req->best_parent_rate;
+
+	if (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {
+		unsigned long best_parent;
+
+		best_parent = req->rate / ccu->n_width * ccu->m_width;
+		*parent_rate = clk_hw_round_rate(clk_hw_get_parent(hw),
+						 best_parent);
+	}
+
+	req->rate = *parent_rate / ccu->m_width * ccu->n_width;
+	return 0;
+}
+
+int ccu_fixed_factor_set_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long parent_rate)
+{
+	return 0;
+}
+
+const struct clk_ops ccu_fixed_factor_ops = {
+	.disable	= ccu_disable,
+	.enable		= ccu_enable,
+/*	.is_enabled	= NULL, */
+
+	.determine_rate	= ccu_fixed_factor_determine_rate,
+	.recalc_rate	= ccu_fixed_factor_recalc_rate,
+	.set_rate	= ccu_fixed_factor_set_rate,
+};
+
+/* --- phase --- */
+static int ccu_phase_get_phase(struct clk_hw *hw)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	struct clk_hw *parent, *grandparent;
+	unsigned int parent_rate, grandparent_rate;
+	u16 step, parent_div;
+	u32 reg;
+	u8 delay;
+
+	reg = readl(ccu->base + ccu->reg);
+	delay = (reg >> ccu->p_shift);
+	delay &= (1 << ccu->p_width) - 1;
+
+	if (!delay)
+		return 180;
+
+	/* Get our parent clock, it's the one that can adjust its rate */
+	parent = clk_hw_get_parent(hw);
+	if (!parent)
+		return -EINVAL;
+
+	/* And its rate */
+	parent_rate = clk_hw_get_rate(parent);
+	if (!parent_rate)
+		return -EINVAL;
+
+	/* Now, get our parent's parent (most likely some PLL) */
+	grandparent = clk_hw_get_parent(parent);
+	if (!grandparent)
+		return -EINVAL;
+
+	/* And its rate */
+	grandparent_rate = clk_hw_get_rate(grandparent);
+	if (!grandparent_rate)
+		return -EINVAL;
+
+	/* Get our parent clock divider */
+	parent_div = grandparent_rate / parent_rate;
+
+	step = DIV_ROUND_CLOSEST(360, parent_div);
+	return delay * step;
+}
+
+static int ccu_phase_set_phase(struct clk_hw *hw, int degrees)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	struct clk_hw *parent, *grandparent;
+//	struct ccu *ccu_parent;
+//	u32 reg
+	unsigned int parent_rate, grandparent_rate;
+	u32 mask;
+	u8 delay = 0;
+	u16 step, parent_div;
+
+	if (degrees == 180)
+		goto set_phase;
+
+	/* Get our parent clock, it's the one that can adjust its rate */
+	parent = clk_hw_get_parent(hw);
+	if (!parent)
+		return -EINVAL;
+
+#if 0
+	/* no delay when new mode */
+	ccu_parent = hw2ccu(parent);
+	if (ccu_parent->extra && ccu_parent->extra->mode_select.rate != 0) {
+		reg = readl(ccu_parent->base + ccu_parent->reg);
+		if (reg & BIT(ccu_parent->extra->mode_select.bit))
+			goto set_phase;
+	}
+#endif
+
+	/* And its rate */
+	parent_rate = clk_hw_get_rate(parent);
+	if (!parent_rate)
+		return -EINVAL;
+
+	/* Now, get our parent's parent (most likely some PLL) */
+	grandparent = clk_hw_get_parent(parent);
+	if (!grandparent)
+		return -EINVAL;
+
+	/* And its rate */
+	grandparent_rate = clk_hw_get_rate(grandparent);
+	if (!grandparent_rate)
+		return -EINVAL;
+
+	/* Get our parent divider */
+	parent_div = grandparent_rate / parent_rate;
+
+	/*
+	 * We can only outphase the clocks by multiple of the
+	 * PLL's period.
+	 *
+	 * Since our parent clock is only a divider, and the
+	 * formula to get the outphasing in degrees is deg =
+	 * 360 * delta / period
+	 *
+	 * If we simplify this formula, we can see that the
+	 * only thing that we're concerned about is the number
+	 * of period we want to outphase our clock from, and
+	 * the divider set by our parent clock.
+	 */
+	step = DIV_ROUND_CLOSEST(360, parent_div);
+	delay = DIV_ROUND_CLOSEST(degrees, step);
+
+set_phase:
+	mask = CCU_MASK(ccu->p_shift, ccu->p_width);
+	ccu_set_field(ccu, ccu->reg, mask, delay << ccu->p_shift);
+
+	return 0;
+}
+
+const struct clk_ops ccu_phase_ops = {
+	.get_phase	= ccu_phase_get_phase,
+	.set_phase	= ccu_phase_set_phase,
+};
+
+/* --- reset --- */
+static inline
+struct ccu_reset *rcdev_to_ccu_reset(struct reset_controller_dev *rcdev)
+{
+	return container_of(rcdev, struct ccu_reset, rcdev);
+}
+
+static void ccu_set_reset_clock(struct ccu_reset *ccu_reset,
+				int reg, int bit, int enable)
+{
+	u32 mask;
+
+	if (!reg)			/* compatibility */
+		return;
+
+	ccu_dbg("reset %03x %d %sassert\n",
+		reg, bit, enable ? "de-" : "");
+
+	mask = BIT(bit);
+
+	spin_lock(&ccu_lock);
+	if (enable)
+		writel(readl(ccu_reset->base + reg) | mask,
+			ccu_reset->base + reg);
+	else
+		writel(readl(ccu_reset->base + reg) & ~mask,
+			ccu_reset->base + reg);
+	spin_unlock(&ccu_lock);
+}
+
+static int ccu_reset_assert(struct reset_controller_dev *rcdev,
+			    unsigned long id)
+{
+	struct ccu_reset *ccu_reset = rcdev_to_ccu_reset(rcdev);
+	const struct ccu_reset_map *map = &ccu_reset->reset_map[id];
+
+	ccu_set_reset_clock(ccu_reset, map->reg, map->bit, 0);
+
+	return 0;
+}
+
+static int ccu_reset_deassert(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	struct ccu_reset *ccu_reset = rcdev_to_ccu_reset(rcdev);
+	const struct ccu_reset_map *map = &ccu_reset->reset_map[id];
+
+	ccu_set_reset_clock(ccu_reset, map->reg, map->bit, 1);
+
+	return 0;
+}
+
+const struct reset_control_ops ccu_reset_ops = {
+	.assert		= ccu_reset_assert,
+	.deassert	= ccu_reset_deassert,
+};
+
+/* --- init --- */
+int __init ccu_probe(struct device_node *node,
+			struct clk_hw_onecell_data *data,
+			struct ccu_reset *resets)
+{
+	struct clk_hw *hw;
+	struct ccu *ccu;
+	void __iomem *reg;
+	int i, ret;
+
+#if 1
+	reg = of_iomap(node, 0);
+	if (!reg) {
+		pr_err("%s: Clock mapping failed\n",
+			of_node_full_name(node));
+		return -EINVAL;
+	}
+#else
+	reg = of_io_request_and_map(node, 0, of_node_full_name(node));
+	if (IS_ERR(reg)) {
+		pr_err("%s: Clock mapping failed %d\n",
+			of_node_full_name(node), (int) PTR_ERR(reg));
+		return PTR_ERR(reg);
+	}
+#endif
+
+	/* register the clocks */
+	for (i = 0; i < data->num; i++) {
+		hw = data->hws[i];
+#if CCU_DEBUG
+		if (!hw) {
+			ccu_dbg("%s: Bad number of clocks %d != %d\n",
+				of_node_full_name(node),
+				i + 1, data->num);
+			data->num = i;
+			break;
+		}
+#endif
+		ccu = hw2ccu(hw);
+		ccu->base = reg;
+		ret = clk_hw_register(NULL, hw);
+		if (ret < 0) {
+			pr_err("%s: Register clock[%d] %s failed %d\n",
+				of_node_full_name(node), i,
+				clk_hw_get_name(hw), ret);
+			data->num = i;
+			break;
+		}
+	}
+	ret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, data);
+	if (ret < 0)
+		goto err;
+
+	/* register the resets */
+	resets->rcdev.of_node = node;
+	resets->base = reg;
+
+	ret = reset_controller_register(&resets->rcdev);
+	if (ret) {
+		pr_err("%s: Reset register failed %d\n",
+			of_node_full_name(node), ret);
+		goto err;
+	}
+
+	return ret;
+
+err:
+	/* don't do anything, otherwise no uart anymore */
+	return ret;
+}
diff --git a/drivers/clk/sunxi/ccu.h b/drivers/clk/sunxi/ccu.h
new file mode 100644
index 0000000..262c3fc
--- /dev/null
+++ b/drivers/clk/sunxi/ccu.h
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or 
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef _CCU_H_
+#define _CCU_H_
+
+struct device_node;
+
+#define CCU_HW(_name, _parent, _ops, _flags)			\
+	.hw.init = &(struct clk_init_data) {			\
+		.flags		= _flags,			\
+		.name		= _name,			\
+		.parent_names	= (const char *[]) { _parent },	\
+		.num_parents	= 1,				\
+		.ops 		= _ops,				\
+	}
+#define CCU_HW_PARENTS(_name, _parents, _ops, _flags)		\
+	.hw.init = &(struct clk_init_data) {			\
+		.flags		= _flags,			\
+		.name		= _name,			\
+		.parent_names	= _parents,			\
+		.num_parents	= ARRAY_SIZE(_parents),		\
+		.ops 		= _ops,				\
+	}
+
+#define CCU_REG(_reg) .reg = _reg
+#define CCU_RESET(_reg, _bit) .reset_reg = _reg, .reset_bit = _bit
+#define CCU_BUS(_reg, _bit) .bus_reg = _reg, .bus_bit = _bit
+#define CCU_GATE(_bit) .has_gate = 1, .gate_bit = _bit
+#define CCU_LOCK(_reg, _bit) .lock_reg = _reg, .lock_bit = _bit
+#define CCU_MUX(_shift, _width) .mux_shift = _shift, .mux_width = _width
+#define CCU_N(_shift, _width) .n_shift = _shift, .n_width = _width
+#define CCU_D1(_shift, _width) .d1_shift = _shift, .d1_width = _width
+#define CCU_D2(_shift, _width) .p_shift = _shift, .p_width = _width
+#define CCU_K(_shift, _width) .k_shift = _shift, .k_width = _width
+#define CCU_M(_shift, _width) .m_shift = _shift, .m_width = _width
+#define CCU_P(_shift, _width) .p_shift = _shift, .p_width = _width
+#define CCU_UPD(_bit) .upd_bit = _bit
+/* with ccu_fixed_factor_ops */
+#define CCU_FIXED(_mul, _div) .n_width = _mul, .m_width = _div
+/* with ccu_phase_ops */
+#define CCU_PHASE(_shift, _width) .p_shift = _shift, .p_width = _width
+
+#define CCU_FEATURE_MUX_VARIABLE_PREDIV	BIT(0)
+#define CCU_FEATURE_MUX_FIXED_PREDIV	BIT(1)
+#define CCU_FEATURE_FIXED_POSTDIV	BIT(2)
+#define CCU_FEATURE_N0			BIT(3)
+#define CCU_FEATURE_MODE_SELECT		BIT(4)
+#define CCU_FEATURE_FLAT_FACTORS	BIT(5)
+#define CCU_FEATURE_SET_RATE_GATE	BIT(6)
+#define CCU_FEATURE_M_TABLE		BIT(7)
+
+/* extra */
+#define CCU_EXTRA_FRAC(_frac) .frac = _frac, .num_frac = ARRAY_SIZE(_frac)
+#define CCU_EXTRA_POST_DIV(_div) .fixed_div[0] = _div
+
+/* fractional values */
+struct frac {
+	unsigned long rate;
+	u32 mask;
+	u32 val;
+};
+
+/* extra features */
+struct ccu_extra {
+	const struct frac *frac; /* array - last is the fractional mask/value */
+	u8 num_frac;
+
+	u8 fixed_div[4];		/* index = parent */
+
+	struct {
+		u8 index;
+		u8 shift;
+		u8 width;
+	} variable_prediv;
+
+	struct {
+		unsigned long rate;
+		u8 bit;
+	} mode_select;
+
+	u8 m_table[8];
+};
+
+struct ccu {
+	struct clk_hw hw;
+
+	void __iomem *base;
+	u16 reg;
+
+	u16 reset_reg, bus_reg, lock_reg;
+	u8  reset_bit, bus_bit, lock_bit;
+	u8 has_gate, gate_bit;
+
+	u8 mux_shift, mux_width;
+	u8 n_shift, n_width, n_min;
+	u8 d1_shift, d1_width;
+//	u8 d2_shift, d2_width;		// d2 is p (never d2 + p)
+	u8 k_shift, k_width;
+	u8 m_shift, m_width;
+	u8 p_shift, p_width;
+
+	u8 upd_bit;
+
+	u16 features;
+
+	const struct ccu_extra *extra;
+};
+
+struct ccu_reset_map {
+	u16	reg;
+	u16	bit;
+};
+
+struct ccu_reset {
+	void __iomem			*base;
+	const struct ccu_reset_map	*reset_map;
+	struct reset_controller_dev	rcdev;
+};
+
+extern const struct clk_ops ccu_fixed_factor_ops;
+extern const struct clk_ops ccu_periph_ops;
+extern const struct clk_ops ccu_pll_ops;
+extern const struct clk_ops ccu_phase_ops;
+extern const struct reset_control_ops ccu_reset_ops;
+
+static inline struct ccu *hw2ccu(struct clk_hw *hw)
+{
+	return container_of(hw, struct ccu, hw);
+}
+
+int ccu_probe(struct device_node *node,
+		struct clk_hw_onecell_data *data,
+		struct ccu_reset *resets);
+
+/* functions exported for specific features */
+void ccu_set_field(struct ccu *ccu, int reg, u32 mask, u32 val);
+int ccu_fixed_factor_determine_rate(struct clk_hw *hw,
+				struct clk_rate_request *req);
+unsigned long ccu_fixed_factor_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate);
+int ccu_fixed_factor_set_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long parent_rate);
+
+#endif /* _CCU_H_ */
diff --git a/drivers/clk/sunxi/ccu-sun8i-a83t.c b/drivers/clk/sunxi/ccu-sun8i-a83t.c
new file mode 100644
index 0000000..dd1c8f8
--- /dev/null
+++ b/drivers/clk/sunxi/ccu-sun8i-a83t.c
@@ -0,0 +1,941 @@
+/*
+ * Copyright (c) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/reset-controller.h>
+
+#include <dt-bindings/clock/sun8i-a83t.h>
+#include <dt-bindings/reset/sun8i-a83t.h>
+
+#include "ccu.h"
+
+static const char losc[32] = "osc32k";
+static const char hosc[32] = "osc24M";
+
+/* 2 * cpux */
+/*	rate = 24MHz * n / p */
+static struct ccu pll_c0cpux_clk = {
+	CCU_REG(0x000),
+	CCU_HW("pll-c0cpux", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 0),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_P(16, 1),			/* only when rate < 288MHz */
+	.features = CCU_FEATURE_N0,
+};
+
+static struct ccu pll_c1cpux_clk = {
+	CCU_REG(0x004),
+	CCU_HW("pll-c1cpux", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 1),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_P(16, 1),			/* only when rate < 288MHz */
+	.features = CCU_FEATURE_N0,
+};
+
+/* audio */
+/*	rate = 24MHz * n / (d1 + 1) / (d2 + 1) / (p + 1) */
+static struct ccu pll_audio_clk = {
+	CCU_REG(0x008),
+	CCU_HW("pll-audio", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 2),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	CCU_M(0, 6),		/* p = divider */
+	.features = CCU_FEATURE_N0,
+};
+
+/* video 0 */
+/*	rate = 24MHz * n / (d1 + 1) >> p */
+static struct ccu pll_video0_clk = {
+	CCU_REG(0x010),
+	CCU_HW("pll-video0", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 3),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_P(0, 2),
+	.features = CCU_FEATURE_N0,
+};
+
+/* video engine */
+/*	rate = 24MHz * n / (d1 + 1) / (d2 + 1) */
+static struct ccu pll_ve_clk = {
+	CCU_REG(0x018),
+	CCU_HW("pll-ve", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 4),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	.features = CCU_FEATURE_N0,
+};
+
+/* ddr */
+/*	rate = 24MHz * (n + 1) / (d1 + 1) / (d2 + 1)
+ *	bit 21: DDR_CLOCK = PLL_DDR / PLL_PERIPH (default DDR)
+ */
+static struct ccu pll_ddr_clk = {
+	CCU_REG(0x020),
+	CCU_HW("pll-ddr", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 5),
+	CCU_N(8, 6), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	CCU_UPD(30),
+};
+
+/* periph */
+/*	rate = 24MHz * n / (d1 + 1) / (d2 + 1) */
+static struct ccu pll_periph_clk = {
+	CCU_REG(0x028),
+	CCU_HW("pll-periph", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 6),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	.features = CCU_FEATURE_N0,
+};
+
+/* gpu */
+/*	rate = 24MHz * n / (d1 + 1) / (d2 + 1) */
+static struct ccu pll_gpu_clk = {
+	CCU_REG(0x038),
+	CCU_HW("pll-gpu", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 7),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	.features = CCU_FEATURE_N0,
+};
+
+/* hsic */
+/*	rate = 24MHz * n / (d1 + 1) / (d2 + 1) */
+static struct ccu pll_hsic_clk = {
+	CCU_REG(0x044),
+	CCU_HW("pll-hsic", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 8),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	.features = CCU_FEATURE_N0,
+};
+
+/* display engine */
+/*	rate = 24MHz * n / (d1 + 1) / (d2 + 1) */
+static struct ccu pll_de_clk = {
+	CCU_REG(0x048),
+	CCU_HW("pll-de", hosc, &ccu_pll_ops, 0),
+	CCU_RESET(0x2c4, 12),
+	CCU_BUS(0x64, 12),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 9),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	.features = CCU_FEATURE_N0,
+};
+
+/* video 1 */
+/*	rate = 24MHz * n / (d1 + 1) >> p */
+static struct ccu pll_video1_clk = {
+	CCU_REG(0x04c),
+	CCU_HW("pll-video1", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 10),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_P(0, 2),
+	.features = CCU_FEATURE_N0,
+};
+
+static const char *c0cpux_parents[] = { hosc, "pll-c0cpux" };
+static struct ccu c0cpux_clk = {
+	CCU_REG(0x050),
+	CCU_HW_PARENTS("c0cpux", c0cpux_parents, &ccu_periph_ops,
+							CLK_IS_CRITICAL),
+	CCU_MUX(12, 1),
+};
+
+static struct ccu axi0_clk = {
+	CCU_REG(0x050),
+	CCU_HW("axi0", "c0cpux", &ccu_periph_ops, 0),
+	CCU_M(0, 2),
+};
+
+static const char *c1cpux_parents[] = { hosc, "pll-c1cpux" };
+static struct ccu c1cpux_clk = {
+	CCU_REG(0x050),
+	CCU_HW_PARENTS("c1cpux", c1cpux_parents, &ccu_periph_ops,
+							CLK_IS_CRITICAL),
+	CCU_MUX(28, 1),
+};
+
+static struct ccu axi1_clk = {
+	CCU_REG(0x050),
+	CCU_HW("axi1", "c1cpux", &ccu_periph_ops, 0),
+	CCU_M(16, 2),
+};
+
+static const char *ahb1_parents[] = { losc, hosc,
+					"pll-periph" };
+static const struct ccu_extra ahb1_extra = {
+	.variable_prediv = { .index = 2, .shift = 6, .width = 2 },
+};
+static struct ccu ahb1_clk = {
+	CCU_REG(0x054),
+	CCU_HW_PARENTS("ahb1", ahb1_parents, &ccu_periph_ops, 0),
+	CCU_MUX(12, 2),
+	CCU_P(4, 2),
+	.features = CCU_FEATURE_MUX_VARIABLE_PREDIV,
+	.extra = &ahb1_extra,
+};
+
+static struct ccu apb1_clk = {
+	CCU_REG(0x054),
+	CCU_HW("apb1", "ahb1", &ccu_periph_ops, 0),
+	CCU_M(8, 2),
+};
+
+static const char *apb2_parents[] = { losc, hosc,
+					"pll-periph",
+					"pll-periph" };
+static struct ccu apb2_clk = {
+	CCU_REG(0x058),
+	CCU_HW_PARENTS("apb2", apb2_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_M(0, 5),
+	CCU_P(16, 2),
+};
+
+#if 1 // from bpi-m3 code
+static struct ccu ahb2_clk = {
+	CCU_HW("ahb2", "pll-periph", &ccu_fixed_factor_ops, 0),
+	CCU_FIXED(1, 2),
+};
+#else // from doc
+static const char *ahb2_parents[] = { "ahb1",
+					"pll-periph" };
+static const struct ccu_extra ahb2_extra = {
+	.fixed_div = { 1, 2},
+};
+static struct ccu ahb2_clk = {
+	CCU_REG(0x05c),
+	CCU_HW_PARENTS("ahb2", ahb2_parents, &ccu_periph_ops, 0),
+	CCU_MUX(0, 2),
+	.features = CCU_FEATURE_MUX_FIXED_PREDIV,
+	.extra = &ahb2_extra,
+};
+#endif
+
+static struct ccu bus_mipi_dsi_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-mipi-dsi", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(1),
+};
+static struct ccu bus_ss_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ss", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(5),
+};
+static struct ccu bus_dma_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-dma", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(6),
+};
+static struct ccu bus_mmc0_clk = {
+//	CCU_REG(0x060),
+	CCU_HW("bus-mmc0", "ahb1", &ccu_periph_ops, 0),
+//	CCU_RESET(0x2c0, 8),
+//	CCU_GATE(8),
+};
+static struct ccu bus_mmc1_clk = {
+//	CCU_REG(0x060),
+	CCU_HW("bus-mmc1", "ahb1", &ccu_periph_ops, 0),
+//	CCU_RESET(0x2c0, 9),
+//	CCU_GATE(9),
+};
+static struct ccu bus_mmc2_clk = {
+//	CCU_REG(0x060),
+	CCU_HW("bus-mmc2", "ahb1", &ccu_periph_ops, 0),
+//	CCU_RESET(0x2c0, 10),
+//	CCU_GATE(10),
+};
+static struct ccu bus_nand_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-nand", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(13),
+};
+static struct ccu bus_dram_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-dram", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(14),
+};
+static struct ccu bus_emac_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-emac", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(17),
+};
+static struct ccu bus_hstimer_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-hstimer", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(19),
+};
+static struct ccu bus_spi0_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-spi0", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(20),
+};
+static struct ccu bus_spi1_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-spi1", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(21),
+};
+static struct ccu bus_usbdrd_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-usbdrd", "ahb2", &ccu_periph_ops, 0),
+	CCU_GATE(24),
+};
+static struct ccu bus_ehci0_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ehci0", "ahb2", &ccu_periph_ops, 0),
+	CCU_GATE(26),
+};
+static struct ccu bus_ehci1_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ehci1", "ahb2", &ccu_periph_ops, 0),
+	CCU_GATE(27),
+};
+static struct ccu bus_ohci0_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ohci0", "ahb2", &ccu_periph_ops, 0),
+	CCU_GATE(29),
+};
+
+static struct ccu bus_ve_clk = {
+	CCU_REG(0x064),
+	CCU_HW("bus-ve", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(0),
+};
+static struct ccu bus_csi_clk = {
+	CCU_REG(0x064),
+	CCU_HW("bus-csi", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(8),
+};
+static struct ccu bus_gpu_clk= {
+	CCU_REG(0x064),
+	CCU_HW("bus-gpu", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(20),
+};
+static struct ccu bus_msgbox_clk = {
+	CCU_REG(0x064),
+	CCU_HW("bus-msgbox", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(21),
+};
+static struct ccu bus_spinlock_clk = {
+	CCU_REG(0x064),
+	CCU_HW("bus-spinlock", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(22),
+};
+
+static struct ccu bus_spdif_clk = {
+	CCU_REG(0x068),
+	CCU_HW("bus-spdif", "apb1", &ccu_periph_ops, 0),
+	CCU_GATE(1),
+};
+static struct ccu bus_pio_clk = {
+	CCU_REG(0x068),
+	CCU_HW("bus-pio", "apb1", &ccu_periph_ops, 0),
+	CCU_GATE(5),
+};
+static struct ccu bus_i2c0_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-i2c0", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(0),
+};
+static struct ccu bus_i2c1_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-i2c1", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(1),
+};
+static struct ccu bus_i2c2_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-i2c2", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(2),
+};
+static struct ccu bus_uart0_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-uart0", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(16),
+};
+static struct ccu bus_uart1_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-uart1", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(17),
+};
+static struct ccu bus_uart2_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-uart2", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(18),
+};
+static struct ccu bus_uart3_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-uart3", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(19),
+};
+static struct ccu bus_uart4_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-uart4", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(20),
+};
+
+static const char *cci400_parents[] = { hosc,
+					"pll-periph",
+					"pll-hsic" };
+static struct ccu cci400_clk = {
+	CCU_REG(0x078),
+	CCU_HW_PARENTS("cci400", cci400_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_M(0, 2),
+};
+
+static const char *mmc_parents[] = { hosc, "pll-periph" };
+static struct ccu nand_clk = {
+	CCU_REG(0x080),
+	CCU_HW_PARENTS("nand", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static struct ccu mmc0_clk = {
+	CCU_REG(0x088),
+	CCU_HW_PARENTS("mmc0", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 8),
+	CCU_BUS(0x060, 8),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE,
+};
+static struct ccu mmc0_sample_clk = {
+	CCU_REG(0x088),
+	CCU_HW("mmc0_sample", "mmc0", &ccu_phase_ops, 0),
+	CCU_PHASE(20, 3),
+};
+static struct ccu mmc0_output_clk = {
+	CCU_REG(0x088),
+	CCU_HW("mmc0_output", "mmc0", &ccu_phase_ops, 0),
+	CCU_PHASE(8, 3),
+};
+
+static struct ccu mmc1_clk = {
+	CCU_REG(0x08c),
+	CCU_HW_PARENTS("mmc1", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 9),
+	CCU_BUS(0x060, 9),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE,
+};
+static struct ccu mmc1_sample_clk = {
+	CCU_REG(0x08c),
+	CCU_HW("mmc1_sample", "mmc1", &ccu_phase_ops, 0),
+	CCU_PHASE(20, 3),
+};
+static struct ccu mmc1_output_clk = {
+	CCU_REG(0x08c),
+	CCU_HW("mmc1_output", "mmc1", &ccu_phase_ops, 0),
+	CCU_PHASE(8, 3),
+};
+
+#if 0 // other version - not coded
+static const struct ccu_extra mmc_extra = {
+	.mode_select.rate = 104000000,
+};
+static struct ccu mmc2mod_clk = {
+	CCU_REG(0x090),
+	CCU_HW_PARENTS("mmc2mod", mmc_parents, &ccu_periph_ops, 0),
+	CCU_M(30, 1),
+	.features = CCU_FEATURE_MODE_SELECT,
+	.extra = &mmc_extra,
+};
+static struct ccu mmc2_clk = {
+	CCU_REG(0x090),
+	CCU_HW("mmc2", "mmc2mod", &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 10),
+	CCU_BUS(0x060, 10),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE,
+};
+#else // works fine enough
+static const struct ccu_extra mmc_extra = {
+	.mode_select.rate = 100000000,
+	.mode_select.bit = 30,
+};
+static struct ccu mmc2_clk = {
+	CCU_REG(0x090),
+	CCU_HW_PARENTS("mmc2", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 10),
+	CCU_BUS(0x060, 10),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE |
+			CCU_FEATURE_MODE_SELECT,
+/*			| CCU_FEATURE_MUX_FIXED_PREDIV,	dynamically set */
+	.extra = &mmc_extra,
+};
+#endif
+static struct ccu mmc2_sample_clk = {
+	CCU_REG(0x090),
+	CCU_HW("mmc2_sample", "mmc2", &ccu_phase_ops, 0),
+	CCU_PHASE(20, 3),
+};
+static struct ccu mmc2_output_clk = {
+	CCU_REG(0x090),
+	CCU_HW("mmc2_output", "mmc2", &ccu_phase_ops, 0),
+	CCU_PHASE(8, 3),
+};
+
+static struct ccu ss_clk = {
+	CCU_REG(0x09c),
+	CCU_HW_PARENTS("ss", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static struct ccu spi0_clk = {
+	CCU_REG(0x0a0),
+	CCU_HW_PARENTS("spi0", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static struct ccu spi1_clk = {
+	CCU_REG(0x0a4),
+	CCU_HW_PARENTS("spi1", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static struct ccu daudio0_clk = {
+	CCU_REG(0x0b0),
+	CCU_HW("daudio0", "pll-audio", &ccu_periph_ops, 0),
+	CCU_BUS(0x068, 12),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+static struct ccu daudio1_clk = {
+	CCU_REG(0x0b4),
+	CCU_HW("daudio1", "pll-audio", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+	CCU_BUS(0x068, 13),
+	CCU_M(0, 4),
+};
+
+static struct ccu daudio2_clk = {
+	CCU_REG(0x0b8),
+	CCU_HW("daudio2", "pll-audio", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+	CCU_BUS(0x068, 14),
+	CCU_M(0, 4),
+};
+
+static struct ccu tdm_clk = {
+	CCU_REG(0x0bc),
+	CCU_HW("tdm", "pll-audio", &ccu_periph_ops, 0),
+	CCU_BUS(0x068, 15),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static struct ccu spdif_clk = {
+	CCU_REG(0x0c0),
+	CCU_HW("spdif", "pll-audio", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static struct ccu usb_phy0_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("usb-phy0", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(8),
+};
+
+static struct ccu usb_phy1_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("usb-phy1", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(9),
+};
+
+static struct ccu usb_hsic_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("usb-hsic", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(10),
+};
+
+static struct ccu osc12m_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("osc12M", hosc, &ccu_fixed_factor_ops, 0),
+	CCU_GATE(11),
+	CCU_FIXED(1, 2),
+};
+
+static struct ccu ohci0_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("ohci0", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(16),
+};
+
+static struct ccu dram_clk = {
+	CCU_REG(0x0f4),
+	CCU_HW("dram", "pll-ddr", &ccu_periph_ops, 0),
+	CCU_M(0, 4),
+	CCU_UPD(16),
+};
+
+/* pll_ddr config not done */
+
+static struct ccu dram_ve_clk = {
+	CCU_REG(0x0100),
+	CCU_HW("dram-ve", "dram", &ccu_periph_ops, 0),
+	CCU_GATE(0),
+};
+
+static struct ccu dram_csi_clk = {
+	CCU_REG(0x0100),
+	CCU_HW("dram-csi", "dram", &ccu_periph_ops, 0),
+	CCU_GATE(1),
+};
+
+static struct ccu tcon0_clk = {
+	CCU_REG(0x118),
+	CCU_HW("tcon0", "pll-video0", &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c4, 4),
+	CCU_BUS(0x064, 4),
+	CCU_GATE(31),
+};
+
+static struct ccu tcon1_clk = {
+	CCU_REG(0x11c),
+	CCU_HW("tcon1", "pll-video1", &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c4, 5),
+	CCU_BUS(0x064, 5),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static struct ccu csi_misc_clk = {
+	CCU_REG(0x0130),
+	CCU_HW("csi-misc", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(16),
+};
+
+static struct ccu mipi_csi_clk = {
+	CCU_REG(0x0130),
+	CCU_HW("mipi-csi", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(31),
+};
+
+/* hack: "losc" is used for no parent */
+static const char *csi_sclk_parents[] = { "pll-periph",
+					losc, losc, losc, losc,
+					"pll-ve" };
+static struct ccu csi_sclk_clk = {
+	CCU_REG(0x134),
+	CCU_HW_PARENTS("csi-sclk", csi_sclk_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 3),
+	CCU_GATE(31),
+	CCU_M(16, 4),
+};
+
+/* hack: "losc" is used for no parent */
+static const char *csi_mclk_parents[] = { losc, losc, losc,
+					"pll-periph",
+					losc,
+					hosc };
+static struct ccu csi_mclk_clk = {
+	CCU_REG(0x134),
+	CCU_HW_PARENTS("csi-mclk", csi_mclk_parents, &ccu_periph_ops, 0),
+	CCU_MUX(8, 3),
+	CCU_GATE(15),
+	CCU_M(0, 5),
+};
+
+static struct ccu ve_clk = {
+	CCU_REG(0x13c),
+	CCU_HW("ve", "pll-ve", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+	CCU_M(16, 3),
+};
+
+static struct ccu avs_clk = {
+	CCU_REG(0x0144),
+	CCU_HW("avs", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(31),
+};
+
+static struct ccu hdmi_clk = {
+	CCU_REG(0x150),
+	CCU_HW("hdmi", "pll-video1", &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_BUS(0x064, 11),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static struct ccu hdmi_ddc_clk = {
+	CCU_REG(0x0154),
+	CCU_HW("hdmi-ddc", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(31),
+};
+
+static const char *mbus_parents[] = { hosc, "pll-periph",
+					"pll-ddr" };
+static struct ccu mbus_clk = {
+	CCU_REG(0x15c),
+	CCU_HW_PARENTS("mbus", mbus_parents, &ccu_periph_ops, CLK_IS_CRITICAL),
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 3),
+};
+
+static struct ccu mipi_dsi0_clk = {
+	CCU_REG(0x168),
+	CCU_HW("mipi-dsi0", "pll-video0", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char *mipi_dsi1_parents[] = { hosc,
+//--fixme: declare null_clk "null" with fixed factor mul=0
+/* hack: "losc" is used for no parent */
+				losc, losc, losc, losc,
+					losc, losc, losc, losc,
+				"pll-video0" };
+static struct ccu mipi_dsi1_clk = {
+	CCU_REG(0x16c),
+	CCU_HW_PARENTS("mipi-dsi1", mipi_dsi1_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 4),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static struct ccu gpu_core_clk = {
+	CCU_REG(0x1a0),
+	CCU_HW("gpu-core", "pll-gpu", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+	CCU_M(0, 3),
+};
+
+static const char *gpu_mem_parents[] = { "pll-gpu", "pll-periph" };
+static struct ccu gpu_mem_clk = {
+	CCU_REG(0x1a4),
+	CCU_HW_PARENTS("gpu-mem", gpu_mem_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 1),
+	CCU_GATE(31),
+	CCU_M(0, 3),
+};
+
+static struct ccu gpu_hyd_clk = {
+	CCU_REG(0x1a8),
+	CCU_HW("gpu-hyd", "pll-gpu", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+	CCU_M(0, 3),
+};
+
+static struct clk_hw_onecell_data sun8i_a83t_ccu_data = {
+	.num = 93,
+	.hws = {
+		[CLK_BUS_DMA]		= (struct clk_hw *) &bus_dma_clk.hw,
+		[CLK_BUS_EHCI0]		= &bus_ehci0_clk.hw,
+		[CLK_BUS_EHCI1]		= &bus_ehci1_clk.hw,
+		[CLK_BUS_MMC0]		= &bus_mmc0_clk.hw,
+		[CLK_BUS_MMC1]		= &bus_mmc1_clk.hw,
+		[CLK_BUS_MMC2]		= &bus_mmc2_clk.hw,
+		[CLK_BUS_OHCI0]		= &bus_ohci0_clk.hw,
+		[CLK_BUS_PIO]		= &bus_pio_clk.hw,
+		[CLK_BUS_UART0]		= &bus_uart0_clk.hw,
+		[CLK_BUS_UART1]		= &bus_uart1_clk.hw,
+		[CLK_BUS_UART2]		= &bus_uart2_clk.hw,
+		[CLK_BUS_UART3]		= &bus_uart3_clk.hw,
+		[CLK_BUS_UART4]		= &bus_uart4_clk.hw,
+		[CLK_BUS_USBDRD]	= &bus_usbdrd_clk.hw,
+		[CLK_DAUDIO0]		= &daudio0_clk.hw,
+		[CLK_DAUDIO1]		= &daudio1_clk.hw,
+		[CLK_DAUDIO2]		= &daudio2_clk.hw,
+		[CLK_HDMI]		= &hdmi_clk.hw,
+		[CLK_HDMI_DDC]		= &hdmi_ddc_clk.hw,
+		[CLK_MMC0]		= &mmc0_clk.hw,
+		[CLK_MMC0_SAMPLE]	= &mmc0_sample_clk.hw,
+		[CLK_MMC0_OUTPUT]	= &mmc0_output_clk.hw,
+		[CLK_MMC1]		= &mmc1_clk.hw,
+		[CLK_MMC1_SAMPLE]	= &mmc1_sample_clk.hw,
+		[CLK_MMC1_OUTPUT]	= &mmc1_output_clk.hw,
+		[CLK_MMC2]		= &mmc2_clk.hw,
+		[CLK_MMC2_SAMPLE]	= &mmc2_sample_clk.hw,
+		[CLK_MMC2_OUTPUT]	= &mmc2_output_clk.hw,
+		[CLK_OHCI0]		= &ohci0_clk.hw,
+		[CLK_OSC12M]		= &osc12m_clk.hw,
+		[CLK_PLL_AUDIO]		= &pll_audio_clk.hw,
+		[CLK_PLL_DE]		= &pll_de_clk.hw,
+		[CLK_PLL_GPU]		= &pll_gpu_clk.hw,
+		[CLK_PLL_HSIC]		= &pll_hsic_clk.hw,
+		[CLK_PLL_PERIPH]	= &pll_periph_clk.hw,
+		[CLK_PLL_VE]		= &pll_ve_clk.hw,
+		[CLK_PLL_VIDEO0]	= &pll_video0_clk.hw,
+		[CLK_PLL_VIDEO1]	= &pll_video1_clk.hw,
+		[CLK_SPDIF]		= &spdif_clk.hw,
+		[CLK_SPI0]		= &spi0_clk.hw,
+		[CLK_SPI1]		= &spi1_clk.hw,
+		[CLK_TCON0]		= &tcon0_clk.hw,
+		[CLK_TCON1]		= &tcon1_clk.hw,
+		[CLK_TDM]		= &tdm_clk.hw,
+		[CLK_USB_PHY0]		= &usb_phy0_clk.hw,
+		[CLK_USB_PHY1]		= &usb_phy1_clk.hw,
+		[CLK_USB_HSIC]		= &usb_hsic_clk.hw,
+		[CLK_VE]		= &ve_clk.hw,
+		&pll_c0cpux_clk.hw,
+		&pll_c1cpux_clk.hw,
+		&pll_ddr_clk.hw,			/* 50 */
+		&c0cpux_clk.hw,
+		&axi0_clk.hw,
+		&c1cpux_clk.hw,
+		&axi1_clk.hw,
+		&ahb1_clk.hw,
+		&apb1_clk.hw,
+		&apb2_clk.hw,
+		&ahb2_clk.hw,
+		&bus_mipi_dsi_clk.hw,
+		&bus_ss_clk.hw,				/* 60 */
+		&bus_nand_clk.hw,
+		&bus_dram_clk.hw,
+		&bus_emac_clk.hw,
+		&bus_hstimer_clk.hw,
+		&bus_spi0_clk.hw,
+		&bus_spi1_clk.hw,
+		&bus_ve_clk.hw,
+		&bus_csi_clk.hw,
+		&bus_gpu_clk.hw,
+		&bus_msgbox_clk.hw,			/* 70 */
+		&bus_spinlock_clk.hw,
+		&bus_spdif_clk.hw,
+		&bus_i2c0_clk.hw,
+		&bus_i2c1_clk.hw,
+		&bus_i2c2_clk.hw,
+		&cci400_clk.hw,
+		&nand_clk.hw,
+		&ss_clk.hw,
+		&dram_clk.hw,
+		&dram_ve_clk.hw,			/* 80 */
+		&dram_csi_clk.hw,
+		&csi_misc_clk.hw,
+		&mipi_csi_clk.hw,
+		&csi_sclk_clk.hw,
+		&csi_mclk_clk.hw,
+		&avs_clk.hw,
+		&mbus_clk.hw,
+		&mipi_dsi0_clk.hw,
+		&mipi_dsi1_clk.hw,
+		&gpu_core_clk.hw,			/* 90 */
+		&gpu_mem_clk.hw,
+		&gpu_hyd_clk.hw,
+	},
+};
+
+static struct ccu_reset_map sun8i_a83t_ccu_resets[] = {
+	[RST_USB_PHY0]	=  { 0x0cc, 0 },
+	[RST_USB_PHY1]	=  { 0x0cc, 1 },
+	[RST_USB_HSIC]	=  { 0x0cc, 2 },
+
+	[RST_DRAM_CTR]	=  { 0x0f4, 31 },
+	[RST_MBUS]	=  { 0x0fc, 31 },
+
+	[RST_MIPI_DSI]	=  { 0x2c0, 1 },
+	[RST_CE]	=  { 0x2c0, 5 },
+	[RST_DMA]	=  { 0x2c0, 6 },
+	[RST_NAND]	=  { 0x2c0, 13 },
+	[RST_DRAM]	=  { 0x2c0, 14 },
+	[RST_EMAC]	=  { 0x2c0, 17 },
+	[RST_HSTIMER]	=  { 0x2c0, 19 },
+	[RST_SPI0]	=  { 0x2c0, 20 },
+	[RST_SPI1]	=  { 0x2c0, 21 },
+	[RST_USBDRD]	=  { 0x2c0, 24 },
+	[RST_EHCI0]	=  { 0x2c0, 26 },
+	[RST_EHCI1]	=  { 0x2c0, 27 },
+	[RST_OHCI0]	=  { 0x2c0, 29 },
+
+	[RST_VE]	=  { 0x2c4, 0 },
+	[RST_CSI]	=  { 0x2c4, 8 },
+	[RST_HDMI0]	=  { 0x2c4, 10 },
+	[RST_HDMI1]	=  { 0x2c4, 11 },
+	[RST_GPU]	=  { 0x2c4, 20 },
+	[RST_MSGBOX]	=  { 0x2c4, 21 },
+	[RST_SPINLOCK]	=  { 0x2c4, 22 },
+
+	[RST_LVDS]	=  { 0x2c8, 0 },
+
+	[RST_SPDIF]	=  { 0x2d0, 1 },
+	[RST_DAUDIO0]	=  { 0x2d0, 12 },
+	[RST_DAUDIO1]	=  { 0x2d0, 13 },
+	[RST_DAUDIO2]	=  { 0x2d0, 14 },
+	[RST_TDM]	=  { 0x2d0, 15 },
+
+	[RST_I2C0]	=  { 0x2d8, 0 },
+	[RST_I2C1]	=  { 0x2d8, 1 },
+	[RST_I2C2]	=  { 0x2d8, 2 },
+	[RST_UART0]	=  { 0x2d8, 16 },
+	[RST_UART1]	=  { 0x2d8, 17 },
+	[RST_UART2]	=  { 0x2d8, 18 },
+	[RST_UART3]	=  { 0x2d8, 19 },
+	[RST_UART4]	=  { 0x2d8, 20 },
+};
+
+static struct ccu_reset sun8i_a83t_resets = {
+	.rcdev.ops = &ccu_reset_ops,
+	.rcdev.owner = THIS_MODULE,
+	.rcdev.nr_resets = ARRAY_SIZE(sun8i_a83t_ccu_resets),
+	.reset_map = sun8i_a83t_ccu_resets,
+};
+
+static void __init sun8i_a83t_ccu_setup(struct device_node *node)
+{
+	ccu_probe(node, &sun8i_a83t_ccu_data,
+			&sun8i_a83t_resets);
+}
+CLK_OF_DECLARE(sun8i_a83t_ccu, "allwinner,sun8i-a83t-ccu",
+	       sun8i_a83t_ccu_setup);
diff --git a/drivers/clk/sunxi/ccu-sun8i-h3.c b/drivers/clk/sunxi/ccu-sun8i-h3.c
new file mode 100644
index 0000000..934179d
--- /dev/null
+++ b/drivers/clk/sunxi/ccu-sun8i-h3.c
@@ -0,0 +1,1030 @@
+/*
+ * Copyright (c) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Based on 'sunxi-ng' from
+ * Copyright (c) 2016 Maxime Ripard. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/reset-controller.h>
+
+#include <dt-bindings/clock/sun8i-h3.h>
+#include <dt-bindings/reset/sun8i-h3.h>
+
+#include "ccu.h"
+
+static const char losc[32] = "osc32k";
+static const char hosc[32] = "osc24M";
+
+/*
+ * Force the pll-audio-1x post-divider to 4
+ * CCU_M(16, 4)
+ */
+static int ccu_h3_pll_audio_prepare(struct clk_hw *hw)
+{
+	struct ccu *ccu = hw2ccu(hw);
+
+	ccu_set_field(ccu, ccu->reg, GENMASK(19, 16), (4 - 1) << 16);
+
+	return 0;
+}
+
+static const struct clk_ops ccu_h3_pll_audio_ops = {
+	.prepare = ccu_h3_pll_audio_prepare,
+
+	.determine_rate = ccu_fixed_factor_determine_rate,
+	.recalc_rate = ccu_fixed_factor_recalc_rate,
+	.set_rate = ccu_fixed_factor_set_rate,
+};
+
+/* cpux */
+/*	rate = 24MHz * (n - 1) * (k - 1) / (m - 1) >> p */
+static struct ccu pll_cpux_clk = {
+	CCU_REG(0x000),
+	CCU_HW("pll-cpux", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x000, 28),
+	CCU_N(8, 5),
+	CCU_K(4, 2),
+	CCU_M(0, 2),
+	CCU_P(16, 2),		/* only if rate < 288MHz */
+	.features = CCU_FEATURE_FLAT_FACTORS,
+};
+
+/* audio */
+/*	rate = 24MHz * (n - 1) / (m - 1) */
+static struct ccu pll_audio_base_clk = {
+	CCU_REG(0x008),
+	CCU_HW("pll-audio-base", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x008, 28),
+	CCU_N(8, 7),
+	CCU_M(0, 5),
+};
+
+/* We hardcode the divider (16,4) to 4 for now */
+static struct ccu pll_audio_clk = {
+	CCU_HW("pll-audio", "pll-audio-base", &ccu_h3_pll_audio_ops,
+						CLK_SET_RATE_PARENT),
+	CCU_FIXED(1, 4),
+};
+static struct ccu pll_audio_2x_clk = {
+	CCU_HW("pll-audio-2x", "pll-audio_base", &ccu_fixed_factor_ops,
+						CLK_SET_RATE_PARENT),
+	CCU_FIXED(1, 2),
+};
+static struct ccu pll_audio_4x_clk = {
+	CCU_HW("pll-audio-4x", "pll-audio_base", &ccu_fixed_factor_ops,
+						CLK_SET_RATE_PARENT),
+	CCU_FIXED(1, 1),
+};
+static struct ccu pll_audio_8x_clk = {
+	CCU_HW("pll-audio-8x", "pll-audio_base", &ccu_fixed_factor_ops,
+						CLK_SET_RATE_PARENT),
+	CCU_FIXED(2, 1),
+};
+
+/* video */
+/*	rate = 24MHz * (n - 1) / (m - 1) */
+#define M_MASK_0_3 0x0f
+static const struct frac video_fracs[] = {
+/*	   rate		mask			    val */
+	{270000000, M_MASK_0_3 | BIT(24) | BIT(25), 0},
+	{297000000, M_MASK_0_3 | BIT(24) | BIT(25), BIT(25)},
+	{0,			 BIT(24) | BIT(25), BIT(24)},
+};
+static const struct ccu_extra video_extra = {
+	CCU_EXTRA_FRAC(video_fracs),
+};
+static struct ccu pll_video_clk = {
+	CCU_REG(0x010),
+	CCU_HW("pll-video", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x010, 28),
+	CCU_N(8, 7),
+	CCU_M(0, 4),
+	.extra = &video_extra,
+};
+
+/* video engine */
+/*	rate = 24MHz * (n - 1) / (m - 1) */
+static struct ccu pll_ve_clk = {
+	CCU_REG(0x018),
+	CCU_HW("pll-ve", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x018, 28),
+	CCU_N(8, 7),
+	CCU_M(0, 4),
+	.extra = &video_extra,
+};
+
+/* ddr */
+/*	rate = 24MHz * (n - 1) * (k - 1) / (m - 1)
+ *	bit 21: DDR_CLOCK = PLL_DDR / PLL_PERIPH (default DDR)
+ */
+static struct ccu pll_ddr_clk = {
+	CCU_REG(0x020),
+	CCU_HW("pll-ddr", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x020, 28),
+	CCU_N(8, 5),
+	CCU_K(4, 2),
+	CCU_M(0, 2),
+	CCU_UPD(20),
+};
+
+/* periph0 */
+/*	rate = 24MHz * (n - 1) * (k - 1) / 2 */
+static const struct ccu_extra periph_extra = {
+	CCU_EXTRA_POST_DIV(2),
+};
+static struct ccu pll_periph0_clk = {
+	CCU_REG(0x028),
+	CCU_HW("pll-periph0", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x028, 28),
+	CCU_N(8, 5),
+	CCU_K(4, 2),
+	.features = CCU_FEATURE_FIXED_POSTDIV,
+	.extra = &periph_extra,
+};
+
+static struct ccu pll_periph0_2x_clk = {
+	CCU_HW("pll-periph0-2x", "pll-periph0", &ccu_fixed_factor_ops, 0),
+	CCU_FIXED(1, 2),
+};
+
+/* gpu */
+/*	rate = 24MHz * (n - 1) / (m - 1) */
+static struct ccu pll_gpu_clk = {
+	CCU_REG(0x038),
+	CCU_HW("pll-gpu", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x038, 28),
+	CCU_N(8, 7),
+	CCU_M(0, 4),
+	.extra = &video_extra,
+};
+
+/* periph1 */
+/*	rate = 24MHz * (n - 1) * (k - 1) / 2 */
+static struct ccu pll_periph1_clk = {
+	CCU_REG(0x044),
+	CCU_HW("pll-periph1", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x044, 28),
+	CCU_N(8, 5),
+	CCU_K(4, 2),
+	.features = CCU_FEATURE_FIXED_POSTDIV,
+	.extra = &periph_extra,
+};
+
+/* display engine */
+/*	rate = 24MHz * (n - 1) / (m - 1) */
+static struct ccu pll_de_clk = {
+	CCU_REG(0x048),
+	CCU_HW("pll-de", hosc, &ccu_pll_ops, 0),
+	CCU_GATE(31),
+	CCU_LOCK(0x048, 28),
+	CCU_N(8, 7),
+	CCU_M(0, 4),
+	.extra = &video_extra,
+};
+
+static const char *cpux_parents[] = { losc, hosc,
+					"pll-cpux", "pll-cpux" };
+static struct ccu cpux_clk = {
+	CCU_REG(0x050),
+	CCU_HW_PARENTS("cpux", cpux_parents, &ccu_periph_ops,
+							CLK_IS_CRITICAL),
+	CCU_MUX(16, 2),
+};
+
+static struct ccu axi_clk = {
+	CCU_REG(0x050),
+	CCU_HW("axi", "cpux", &ccu_periph_ops, 0),
+	CCU_M(0, 2),
+};
+
+static const char *ahb1_parents[] = { losc, hosc,
+					"axi", "pll-periph0" };
+static const struct ccu_extra ahb1_extra = {
+	.variable_prediv = { .index = 3, .shift = 6, .width = 2 },
+};
+static struct ccu ahb1_clk = {
+	CCU_REG(0x054),
+	CCU_HW_PARENTS("ahb1", ahb1_parents, &ccu_periph_ops, 0),
+	CCU_MUX(12, 2),
+	CCU_P(4, 2),
+	.features = CCU_FEATURE_MUX_VARIABLE_PREDIV,
+	.extra = &ahb1_extra,
+};
+
+static const struct ccu_extra apb1_extra = {
+	.m_table = { 2, 2, 4, 8 },
+};
+static struct ccu apb1_clk = {
+	CCU_REG(0x054),
+	CCU_HW("apb1", "ahb1", &ccu_periph_ops, 0),
+	CCU_M(8, 2),
+	.features = CCU_FEATURE_M_TABLE,
+	.extra = &apb1_extra,
+};
+
+static const char *apb2_parents[] = { losc, hosc,
+						"pll-periph0", "pll-periph0" };
+static struct ccu apb2_clk = {
+	CCU_REG(0x058),
+	CCU_HW_PARENTS("apb2", apb2_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_M(0, 5),
+	CCU_P(16, 2),
+};
+
+static const char *ahb2_parents[] = { "ahb1", "pll-periph0" };
+static const struct ccu_extra ahb2_extra = {
+	.fixed_div = { 1, 2 },
+};
+static struct ccu ahb2_clk = {
+	CCU_REG(0x05c),
+	CCU_HW_PARENTS("ahb2", ahb2_parents, &ccu_periph_ops, 0),
+	CCU_MUX(0, 2),
+	.features = CCU_FEATURE_MUX_FIXED_PREDIV,
+	.extra = &ahb2_extra,
+};
+
+static struct ccu bus_ce_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ce", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(5),
+};
+static struct ccu bus_dma_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-dma", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(6),
+};
+static struct ccu bus_mmc0_clk = {
+//	CCU_REG(0x060),
+	CCU_HW("bus-mmc0", "ahb1", &ccu_periph_ops, 0),
+//	CCU_GATE(8),
+//	CCU_RESET(0x2c0, 8),
+};
+static struct ccu bus_mmc1_clk = {
+//	CCU_REG(0x060),
+	CCU_HW("bus-mmc1", "ahb1", &ccu_periph_ops, 0),
+//	CCU_GATE(9),
+//	CCU_RESET(0x2c0, 9),
+};
+static struct ccu bus_mmc2_clk = {
+//	CCU_REG(0x060),
+	CCU_HW("bus-mmc2", "ahb1", &ccu_periph_ops, 0),
+//	CCU_GATE(10),
+//	CCU_RESET(0x2c0, 10),
+};
+static struct ccu bus_nand_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-nand", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(13),
+};
+static struct ccu bus_dram_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-dram", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(14),
+};
+static struct ccu bus_emac_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-emac", "ahb2", &ccu_periph_ops, 0),
+	CCU_GATE(17),
+};
+static struct ccu bus_ts_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ts", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(18),
+};
+static struct ccu bus_hstimer_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-hstimer", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(19),
+};
+static struct ccu bus_spi0_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-spi0", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(20),
+};
+static struct ccu bus_spi1_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-spi1", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(21),
+};
+static struct ccu bus_otg_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-otg", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(23),
+};
+static struct ccu bus_ehci0_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ehci0", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(24),
+};
+static struct ccu bus_ehci1_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ehci1", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(25),
+};
+static struct ccu bus_ehci2_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ehci2", "ahb2", &ccu_periph_ops, 0),
+	CCU_GATE(26),
+};
+static struct ccu bus_ehci3_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ehci3", "ahb2", &ccu_periph_ops, 0),
+	CCU_GATE(27),
+};
+static struct ccu bus_ohci0_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ohci0", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(28),
+};
+static struct ccu bus_ohci1_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ohci1", "ahb2", &ccu_periph_ops, 0),
+	CCU_GATE(29),
+};
+static struct ccu bus_ohci2_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ohci2", "ahb2", &ccu_periph_ops, 0),
+	CCU_GATE(30),
+};
+static struct ccu bus_ohci3_clk = {
+	CCU_REG(0x060),
+	CCU_HW("bus-ohci3", "ahb2", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+};
+
+static struct ccu bus_ve_clk = {
+	CCU_REG(0x064),
+	CCU_HW("bus-ve", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(0),
+};
+static struct ccu bus_deinterlace_clk = {
+	CCU_REG(0x064),
+	CCU_HW("bus-deinterlace", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(5),
+};
+static struct ccu bus_csi_clk = {
+	CCU_REG(0x064),
+	CCU_HW("bus-csi", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(8),
+};
+static struct ccu bus_tve_clk = {
+	CCU_REG(0x064),
+	CCU_HW("bus-tve", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(9),
+};
+static struct ccu bus_gpu_clk = {
+	CCU_REG(0x064),
+	CCU_HW("bus-gpu", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(20),
+};
+static struct ccu bus_msgbox_clk = {
+	CCU_REG(0x064),
+	CCU_HW("bus-msgbox", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(21),
+};
+static struct ccu bus_spinlock_clk = {
+	CCU_REG(0x064),
+	CCU_HW("bus-spinlock", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(22),
+};
+
+static struct ccu bus_codec_clk = {
+	CCU_REG(0x068),
+	CCU_HW("bus-codec", "apb1", &ccu_periph_ops, 0),
+	CCU_GATE(0),
+};
+static struct ccu bus_spdif_clk = {
+	CCU_REG(0x068),
+	CCU_HW("bus-spdif", "apb1", &ccu_periph_ops, 0),
+	CCU_GATE(1),
+};
+static struct ccu bus_pio_clk = {
+	CCU_REG(0x068),
+	CCU_HW("bus-pio", "apb1", &ccu_periph_ops, 0),
+	CCU_GATE(5),
+};
+//static struct ccu bus_ths_clk = {
+//	CCU_REG(0x068),
+//	CCU_HW("bus-ths", "apb1", &ccu_periph_ops, 0),
+//	CCU_GATE(8),
+//};
+
+static struct ccu bus_i2c0_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-i2c0", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(0),
+};
+static struct ccu bus_i2c1_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-i2c1", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(1),
+};
+static struct ccu bus_i2c2_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-i2c2", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(2),
+};
+static struct ccu bus_uart0_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-uart0", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(16),
+};
+static struct ccu bus_uart1_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-uart1", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(17),
+};
+static struct ccu bus_uart2_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-uart2", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(18),
+};
+static struct ccu bus_uart3_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-uart3", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(19),
+};
+static struct ccu bus_scr_clk = {
+	CCU_REG(0x06c),
+	CCU_HW("bus-scr", "apb2", &ccu_periph_ops, 0),
+	CCU_GATE(20),
+};
+
+static struct ccu bus_ephy_clk = {
+	CCU_REG(0x070),
+	CCU_HW("bus-ephy", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(0),
+};
+static struct ccu bus_dbg_clk = {
+	CCU_REG(0x070),
+	CCU_HW("bus-dbg", "ahb1", &ccu_periph_ops, 0),
+	CCU_GATE(7),
+};
+
+static const struct ccu_extra ths_extra = {
+	.m_table = { 1, 2, 4, 6 },
+};
+static struct ccu ths_clk = {
+	CCU_REG(0x074),
+	CCU_HW("ths", hosc, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_BUS(0x068, 8),
+	CCU_GATE(31),
+	CCU_M(0, 2),
+	.features = CCU_FEATURE_M_TABLE,
+	.extra = &ths_extra,
+};
+
+static const char *mmc_parents[] = { hosc, "pll-periph0",
+					"pll-periph1" };
+static struct ccu nand_clk = {
+	CCU_REG(0x080),
+	CCU_HW_PARENTS("nand", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static struct ccu mmc0_clk = {
+	CCU_REG(0x088),
+	CCU_HW_PARENTS("mmc0", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 8),
+	CCU_BUS(0x060, 8),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE,
+};
+static struct ccu mmc0_sample_clk = {
+	CCU_REG(0x088),
+	CCU_HW("mmc0_sample", "mmc0", &ccu_phase_ops, 0),
+	CCU_PHASE(20, 3),
+};
+static struct ccu mmc0_output_clk = {
+	CCU_REG(0x088),
+	CCU_HW("mmc0_output", "mmc0", &ccu_phase_ops, 0),
+	CCU_PHASE(8, 3),
+};
+
+static const struct ccu_extra mmc_extra = {
+	.mode_select.rate = 100000000,
+	.mode_select.bit = 30,
+};
+static struct ccu mmc1_clk = {
+	CCU_REG(0x08c),
+	CCU_HW_PARENTS("mmc1", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 9),
+	CCU_BUS(0x060, 9),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE |
+			CCU_FEATURE_MODE_SELECT,
+/*			| CCU_FEATURE_MUX_FIXED_PREDIV,	dynamically set */
+	.extra = &mmc_extra,
+};
+static struct ccu mmc1_sample_clk = {
+	CCU_REG(0x08c),
+	CCU_HW("mmc1_sample", "mmc1", &ccu_phase_ops, 0),
+	CCU_PHASE(20, 3),
+};
+static struct ccu mmc1_output_clk = {
+	CCU_REG(0x08c),
+	CCU_HW("mmc1_output", "mmc1", &ccu_phase_ops, 0),
+	CCU_PHASE(8, 3),
+};
+
+static struct ccu mmc2_clk = {
+	CCU_REG(0x090),
+	CCU_HW_PARENTS("mmc2", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 10),
+	CCU_BUS(0x060, 10),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE |
+			CCU_FEATURE_MODE_SELECT,
+/*			| CCU_FEATURE_MUX_FIXED_PREDIV,	dynamically set */
+	.extra = &mmc_extra,
+};
+static struct ccu mmc2_sample_clk = {
+	CCU_REG(0x090),
+	CCU_HW("mmc2_sample", "mmc2", &ccu_phase_ops, 0),
+	CCU_PHASE(20, 3),
+};
+static struct ccu mmc2_output_clk = {
+	CCU_REG(0x090),
+	CCU_HW("mmc2_output", "mmc2", &ccu_phase_ops, 0),
+	CCU_PHASE(8, 3),
+};
+
+static const char *ts_parents[] = { hosc, "pll-periph0", };
+static struct ccu ts_clk = {
+	CCU_REG(0x098),
+	CCU_HW_PARENTS("ts", ts_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static struct ccu ce_clk = {
+	CCU_REG(0x09c),
+	CCU_HW_PARENTS("ce", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static struct ccu spi0_clk = {
+	CCU_REG(0x0a0),
+	CCU_HW_PARENTS("spi0", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static struct ccu spi1_clk = {
+	CCU_REG(0x0a4),
+	CCU_HW_PARENTS("spi1", mmc_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static const char *i2s_parents[] = { "pll-audio-8x", "pll_audio-4x",
+					"pll-audio-2x", "pll-audio" };
+static struct ccu i2s0_clk = {
+	CCU_REG(0x0b0),
+	CCU_HW_PARENTS("i2s0", i2s_parents, &ccu_periph_ops, 0),
+	CCU_MUX(16, 2),
+	CCU_BUS(0x068, 12),
+	CCU_GATE(31),
+};
+static struct ccu i2s1_clk = {
+	CCU_REG(0x0b4),
+	CCU_HW_PARENTS("i2s1", i2s_parents, &ccu_periph_ops, 0),
+	CCU_MUX(16, 2),
+	CCU_BUS(0x068, 13),
+	CCU_GATE(31),
+};
+
+static struct ccu i2s2_clk = {
+	CCU_REG(0x0b8),
+	CCU_HW_PARENTS("i2s2", i2s_parents, &ccu_periph_ops, 0),
+	CCU_MUX(16, 2),
+	CCU_BUS(0x068, 14),
+	CCU_GATE(31),
+};
+
+static struct ccu spdif_clk = {
+	CCU_REG(0x0c0),
+	CCU_HW("spdif", "pll-audio", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static struct ccu usb_phy0_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("usb-phy0", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(8),
+};
+
+static struct ccu usb_phy1_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("usb-phy1", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(9),
+};
+
+static struct ccu usb_phy2_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("usb-phy2", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(10),
+};
+
+static struct ccu usb_phy3_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("usb-phy3", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(11),
+};
+
+static struct ccu usb_ohci0_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("usb-ohci0", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(16),
+};
+
+static struct ccu usb_ohci1_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("usb-ohci1", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(17),
+};
+
+static struct ccu usb_ohci2_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("usb-ohci2", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(18),
+};
+
+static struct ccu usb_ohci3_clk = {
+	CCU_REG(0x0cc),
+	CCU_HW("usb-ohci3", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(19),
+};
+
+static struct ccu dram_clk = {
+	CCU_REG(0x0f4),
+	CCU_HW("dram", "pll-ddr", &ccu_periph_ops, CLK_IS_CRITICAL),
+	CCU_MUX(20, 2),
+	CCU_M(0, 4),
+	CCU_UPD(16),
+};
+
+static struct ccu dram_ve_clk = {
+	CCU_REG(0x0100),
+	CCU_HW("dram-ve", "dram", &ccu_periph_ops, 0),
+	CCU_GATE(0),
+};
+
+static struct ccu dram_csi_clk = {
+	CCU_REG(0x100),
+	CCU_HW("dram-csi", "dram", &ccu_periph_ops, 0),
+	CCU_GATE(1),
+};
+
+static struct ccu dram_deinterlace_clk = {
+	CCU_REG(0x0100),
+	CCU_HW("dram-deinterlace", "dram", &ccu_periph_ops, 0),
+	CCU_GATE(2),
+};
+
+static struct ccu dram_ts_clk = {
+	CCU_REG(0x0100),
+	CCU_HW("dram-ts", "dram", &ccu_periph_ops, 0),
+	CCU_GATE(3),
+};
+
+static const char *de_parents[] = { "pll-periph0-2x", "pll-de" };
+static struct ccu de_clk = {
+	CCU_REG(0x104),
+	CCU_HW_PARENTS("de", de_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 3),
+	CCU_RESET(0x2c4, 12),
+	CCU_BUS(0x064, 12),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static struct ccu tcon0_clk = {
+	CCU_REG(0x118),
+	CCU_HW("tcon0", "pll-video", &ccu_periph_ops, 0),
+	CCU_MUX(24, 3),
+//	CCU_RESET(0x2c4, 4),	// tcon1
+//	CCU_BUS(0x064, 4),
+	CCU_RESET(0x2c4, 3),
+	CCU_BUS(0x064, 3),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char *tve_parents[] = { "pll-de", "pll-periph1" };
+static struct ccu tve_clk = {
+	CCU_REG(0x120),
+	CCU_HW_PARENTS("tve", tve_parents, &ccu_periph_ops, 0),
+	CCU_MUX(24, 3),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char *ph0_ph1[] = { "pll-periph0", "pll-periph1" };
+static struct ccu deinterlace_clk = {
+	CCU_REG(0x124),
+	CCU_HW_PARENTS("tve", ph0_ph1, &ccu_periph_ops, 0),
+	CCU_MUX(24, 3),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static struct ccu csi_misc_clk = {
+	CCU_REG(0x0130),
+	CCU_HW("csi-misc", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(16),
+};
+
+static struct ccu csi_sclk_clk = {
+	CCU_REG(0x134),
+	CCU_HW_PARENTS("csi-sclk", ph0_ph1, &ccu_periph_ops, 0),
+	CCU_MUX(24, 3),
+	CCU_GATE(31),
+	CCU_M(16, 4),
+};
+
+static const char *csi_mclk_parents[] = { hosc, "pll-video", "pll-periph0" };
+static struct ccu csi_mclk_clk = {
+	CCU_REG(0x134),
+	CCU_HW_PARENTS("csi-mclk", csi_mclk_parents, &ccu_periph_ops, 0),
+	CCU_MUX(8, 3),
+	CCU_GATE(15),
+	CCU_M(0, 5),
+};
+
+static struct ccu ve_clk = {
+	CCU_REG(0x13c),
+	CCU_HW("ve", "pll-ve", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+	CCU_M(16, 3),
+};
+
+static struct ccu ac_dig_clk = {
+	CCU_REG(0x0140),
+	CCU_HW("ac-dig", "pll-audio", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+};
+
+static struct ccu avs_clk = {
+	CCU_REG(0x0144),
+	CCU_HW("avs", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(31),
+};
+
+static struct ccu hdmi_clk = {
+	CCU_REG(0x150),
+	CCU_HW("hdmi", "pll-video", &ccu_periph_ops, 0),
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_BUS(0x064, 11),
+	CCU_M(0, 4),
+};
+
+static struct ccu hdmi_ddc_clk = {
+	CCU_REG(0x0154),
+	CCU_HW("hdmi-ddc", hosc, &ccu_periph_ops, 0),
+	CCU_GATE(31),
+};
+
+static const char *mbus_parents[] = { hosc, "pll-periph0-2x",
+						"pll-ddr" };
+static struct ccu mbus_clk = {
+	CCU_REG(0x15c),
+	CCU_HW_PARENTS("mbus", mbus_parents, &ccu_periph_ops, CLK_IS_CRITICAL),
+	CCU_GATE(31),
+	CCU_MUX(24, 2),
+	CCU_M(0, 3),
+};
+
+static struct ccu gpu_clk = {
+	CCU_REG(0x1a0),
+	CCU_HW("gpu", "pll-gpu", &ccu_periph_ops, 0),
+	CCU_GATE(31),
+	CCU_M(0, 3),
+};
+
+static struct clk_hw_onecell_data sun8i_h3_ccu_data = {
+	.num = 97,
+	.hws = {
+		[CLK_BUS_DMA]		= &bus_dma_clk.hw,
+		[CLK_BUS_EHCI0]		= &bus_ehci0_clk.hw,
+		[CLK_BUS_EHCI1]		= &bus_ehci1_clk.hw,
+		[CLK_BUS_EHCI2]		= &bus_ehci2_clk.hw,
+		[CLK_BUS_EHCI3]		= &bus_ehci3_clk.hw,
+		[CLK_BUS_MMC0]		= &bus_mmc0_clk.hw,
+		[CLK_BUS_MMC1]		= &bus_mmc1_clk.hw,
+		[CLK_BUS_MMC2]		= &bus_mmc2_clk.hw,
+		[CLK_BUS_OHCI0]		= &bus_ohci0_clk.hw,
+		[CLK_BUS_OHCI1]		= &bus_ohci1_clk.hw,
+		[CLK_BUS_OHCI2]		= &bus_ohci2_clk.hw,
+		[CLK_BUS_OHCI3]		= &bus_ohci3_clk.hw,
+		[CLK_BUS_PIO]		= &bus_pio_clk.hw,
+		[CLK_BUS_UART0]		= &bus_uart0_clk.hw,
+		[CLK_BUS_UART1]		= &bus_uart1_clk.hw,
+		[CLK_BUS_UART2]		= &bus_uart2_clk.hw,
+		[CLK_BUS_UART3]		= &bus_uart3_clk.hw,
+		[CLK_DE]		= &de_clk.hw,
+		[CLK_HDMI]		= &hdmi_clk.hw,
+		[CLK_HDMI_DDC]		= &hdmi_ddc_clk.hw,
+		[CLK_I2S0]		= &i2s0_clk.hw,
+		[CLK_I2S1]		= &i2s1_clk.hw,
+		[CLK_I2S2]		= &i2s2_clk.hw,
+		[CLK_MMC0]		= &mmc0_clk.hw,
+		[CLK_MMC0_SAMPLE]	= &mmc0_sample_clk.hw,
+		[CLK_MMC0_OUTPUT]	= &mmc0_output_clk.hw,
+		[CLK_MMC1]		= &mmc1_clk.hw,
+		[CLK_MMC1_SAMPLE]	= &mmc1_sample_clk.hw,
+		[CLK_MMC1_OUTPUT]	= &mmc1_output_clk.hw,
+		[CLK_MMC2]		= &mmc2_clk.hw,
+		[CLK_MMC2_SAMPLE]	= &mmc2_sample_clk.hw,
+		[CLK_MMC2_OUTPUT]	= &mmc2_output_clk.hw,
+		[CLK_PLL_AUDIO]		= &pll_audio_clk.hw,
+		[CLK_PLL_DE]		= &pll_de_clk.hw,
+		[CLK_PLL_GPU]		= &pll_gpu_clk.hw,
+		[CLK_PLL_PERIPH0]	= &pll_periph0_clk.hw,
+		[CLK_PLL_PERIPH1]	= &pll_periph1_clk.hw,
+		[CLK_PLL_VE]		= &pll_ve_clk.hw,
+		[CLK_PLL_VIDEO]		= &pll_video_clk.hw,
+		[CLK_SPDIF]		= &spdif_clk.hw,
+		[CLK_SPI0]		= &spi0_clk.hw,
+		[CLK_SPI1]		= &spi1_clk.hw,
+		[CLK_TCON0]		= &tcon0_clk.hw,
+		[CLK_THS]		= &ths_clk.hw,
+		[CLK_TVE]		= &tve_clk.hw,
+		[CLK_USB_OHCI0]		= &usb_ohci0_clk.hw,
+		[CLK_USB_OHCI1]		= &usb_ohci1_clk.hw,
+		[CLK_USB_OHCI2]		= &usb_ohci2_clk.hw,
+		[CLK_USB_OHCI3]		= &usb_ohci3_clk.hw,
+		[CLK_USB_PHY0]		= &usb_phy0_clk.hw,
+		[CLK_USB_PHY1]		= &usb_phy1_clk.hw,
+		[CLK_USB_PHY2]		= &usb_phy2_clk.hw,
+		[CLK_USB_PHY3]		= &usb_phy3_clk.hw,
+		[CLK_VE]		= &ve_clk.hw,
+		&pll_cpux_clk.hw,
+		&pll_audio_base_clk.hw,
+		&pll_audio_2x_clk.hw,
+		&pll_audio_4x_clk.hw,
+		&pll_audio_8x_clk.hw,
+		&pll_periph0_2x_clk.hw,
+		&pll_ddr_clk.hw,			/* 60 */
+		&cpux_clk.hw,
+		&axi_clk.hw,
+		&ahb1_clk.hw,
+		&apb1_clk.hw,
+		&apb2_clk.hw,
+		&ahb2_clk.hw,
+		&bus_ce_clk.hw,
+		&bus_nand_clk.hw,
+		&bus_dram_clk.hw,
+		&bus_emac_clk.hw,			/* 70 */
+		&bus_ts_clk.hw,
+		&bus_hstimer_clk.hw,
+		&bus_spi0_clk.hw,
+		&bus_spi1_clk.hw,
+		&bus_otg_clk.hw,
+		&bus_ve_clk.hw,
+		&bus_deinterlace_clk.hw,
+		&bus_csi_clk.hw,
+		&bus_tve_clk.hw,
+		&bus_gpu_clk.hw,			/* 80 */
+		&bus_msgbox_clk.hw,
+		&bus_spinlock_clk.hw,
+		&bus_codec_clk.hw,
+		&bus_spdif_clk.hw,
+		&bus_i2c0_clk.hw,
+		&bus_i2c1_clk.hw,
+		&bus_i2c2_clk.hw,
+		&bus_scr_clk.hw,
+		&bus_ephy_clk.hw,
+		&bus_dbg_clk.hw,			/* 80 */
+		&nand_clk.hw,
+		&ts_clk.hw,
+		&ce_clk.hw,
+		&dram_clk.hw,
+		&dram_ve_clk.hw,
+		&dram_csi_clk.hw,
+		&dram_deinterlace_clk.hw,
+		&dram_ts_clk.hw,
+		&deinterlace_clk.hw,
+		&csi_misc_clk.hw,			/* 90 */
+		&csi_sclk_clk.hw,
+		&csi_mclk_clk.hw,
+		&ac_dig_clk.hw,
+		&avs_clk.hw,
+		&mbus_clk.hw,
+		&gpu_clk.hw,
+	},
+};
+
+static struct ccu_reset_map sun8i_h3_ccu_resets[] = {
+	[RST_USB_PHY0]	= { 0x0cc, 0 },
+	[RST_USB_PHY1]	= { 0x0cc, 1 },
+	[RST_USB_PHY2]	= { 0x0cc, 2 },
+	[RST_USB_PHY3]	= { 0x0cc, 3 },
+
+	[RST_MBUS]	= { 0x0fc, 31 },
+
+	[RST_CE]	= { 0x2c0, 5 },
+	[RST_DMA]	= { 0x2c0, 6 },
+	[RST_NAND]	= { 0x2c0, 13 },
+	[RST_DRAM]	= { 0x2c0, 14 },
+	[RST_EMAC]	= { 0x2c0, 17 },
+	[RST_TS]	= { 0x2c0, 18 },
+	[RST_HSTIMER]	= { 0x2c0, 19 },
+	[RST_SPI0]	= { 0x2c0, 20 },
+	[RST_SPI1]	= { 0x2c0, 21 },
+	[RST_OTG]	= { 0x2c0, 23 },
+	[RST_EHCI0]	= { 0x2c0, 24 },
+	[RST_EHCI1]	= { 0x2c0, 25 },
+	[RST_EHCI2]	= { 0x2c0, 26 },
+	[RST_EHCI3]	= { 0x2c0, 27 },
+	[RST_OHCI0]	= { 0x2c0, 28 },
+	[RST_OHCI1]	= { 0x2c0, 29 },
+	[RST_OHCI2]	= { 0x2c0, 30 },
+	[RST_OHCI3]	= { 0x2c0, 31 },
+
+	[RST_VE]	= { 0x2c4, 0 },
+	[RST_DEINTERLACE] = { 0x2c4, 5 },
+	[RST_CSI]	= { 0x2c4, 8 },
+	[RST_TVE]	= { 0x2c4, 9 },
+	[RST_HDMI0]	= { 0x2c4, 10 },
+	[RST_HDMI1]	= { 0x2c4, 11 },
+	[RST_GPU]	= { 0x2c4, 20 },
+	[RST_MSGBOX]	= { 0x2c4, 21 },
+	[RST_SPINLOCK]	= { 0x2c4, 22 },
+	[RST_DBG]	= { 0x2c4, 31 },
+
+	[RST_EPHY]	= { 0x2c8, 2 },
+
+	[RST_CODEC]	= { 0x2d0, 0 },
+	[RST_SPDIF]	= { 0x2d0, 1 },
+	[RST_THS]	= { 0x2d0, 8 },
+	[RST_I2S0]	= { 0x2d0, 12 },
+	[RST_I2S1]	= { 0x2d0, 13 },
+	[RST_I2S2]	= { 0x2d0, 14 },
+
+	[RST_I2C0]	= { 0x2d4, 0 },
+	[RST_I2C1]	= { 0x2d4, 1 },
+	[RST_I2C2]	= { 0x2d4, 2 },
+	[RST_UART0]	= { 0x2d4, 16 },
+	[RST_UART1]	= { 0x2d4, 17 },
+	[RST_UART2]	= { 0x2d4, 18 },
+	[RST_UART3]	= { 0x2d4, 19 },
+	[RST_SCR]	= { 0x2d4, 20 },
+};
+
+static struct ccu_reset sun8i_h3_resets = {
+	.rcdev.ops = &ccu_reset_ops,
+	.rcdev.owner = THIS_MODULE,
+	.rcdev.nr_resets = ARRAY_SIZE(sun8i_h3_ccu_resets),
+	.reset_map = sun8i_h3_ccu_resets,
+};
+
+static void __init sun8i_h3_ccu_setup(struct device_node *node)
+{
+	ccu_probe(node, &sun8i_h3_ccu_data,
+			&sun8i_h3_resets);
+}
+CLK_OF_DECLARE(sun8i_h3_ccu, "allwinner,sun8i-h3-ccu",
+	       sun8i_h3_ccu_setup);
diff --git a/drivers/gpu/drm/sunxi/Kconfig b/drivers/gpu/drm/sunxi/Kconfig
new file mode 100644
index 0000000..e452930
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/Kconfig
@@ -0,0 +1,20 @@
+#
+# Allwinner Video configuration
+#
+
+config DRM_SUNXI
+	tristate "DRM Support for Allwinner Video"
+	depends on DRM && ARCH_SUNXI
+	depends on OF
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_GEM_CMA_HELPER
+	help
+	  Choose this option if you have a Allwinner chipset.
+
+config DRM_SUNXI_DE2
+	tristate "Support for Allwinner Video with DE2 interface"
+	depends on DRM_SUNXI
+	help
+	  Choose this option if your Allwinner chipset has the DE2 interface
+	  as the H3.
diff --git a/drivers/gpu/drm/sunxi/Makefile b/drivers/gpu/drm/sunxi/Makefile
new file mode 100644
index 0000000..750d9d4
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for Allwinner's sun8i DRM device driver
+#
+
+sunxi-de2-drm-objs := de2_drv.o de2_de.o de2_crtc.o de2_plane.o
+#sunxi-de2-hdmi-objs := de2_hdmi.o de2_hdmi_h3.o
+
+#obj-$(CONFIG_DRM_SUNXI_DE2) += sunxi-de2-drm.o sunxi-de2-hdmi.o
+obj-$(CONFIG_DRM_SUNXI_DE2) += sunxi-de2-drm.o
diff --git a/drivers/gpu/drm/sunxi/de2_crtc.c b/drivers/gpu/drm/sunxi/de2_crtc.c
new file mode 100644
index 0000000..ff099ee
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_crtc.c
@@ -0,0 +1,501 @@
+/*
+ * Allwinner DRM driver - DE2 CRTC
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/component.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <asm/io.h>
+#include <linux/of_irq.h>
+
+#include "de2_drm.h"
+#include "de2_crtc.h"
+
+/* I/O map */
+
+struct tcon {
+	u32 gctl;
+#define		TCON_GCTL_TCON_En BIT(31)
+	u32 gint0;
+#define		TCON_GINT0_TCON1_Vb_Int_En BIT(30)
+#define		TCON_GINT0_TCON1_Vb_Int_Flag BIT(14)
+	u32 gint1;
+	u32 dum0[13];
+	u32 tcon0_ctl;				/* 0x40 */
+#define		TCON0_CTL_TCON_En BIT(31)
+	u32 dum1[19];
+	u32 tcon1_ctl;				/* 0x90 */
+#define		TCON1_CTL_TCON_En BIT(31)
+#define		TCON1_CTL_Interlace_En BIT(20)
+#define		TCON1_CTL_Start_Delay_SHIFT 4
+#define		TCON1_CTL_Start_Delay_MASK GENMASK(8, 4)
+	u32 basic0;			/* XI/YI */
+	u32 basic1;			/* LS_XO/LS_YO */
+	u32 basic2;			/* XO/YO */
+	u32 basic3;			/* HT/HBP */
+	u32 basic4;			/* VT/VBP */
+	u32 basic5;			/* HSPW/VSPW */
+	u32 dum2;
+	u32 ps_sync;				/* 0xb0 */
+	u32 dum3[15];
+	u32 io_pol;				/* 0xf0 */
+#define		TCON1_IO_POL_IO0_inv BIT(24)
+#define		TCON1_IO_POL_IO1_inv BIT(25)
+#define		TCON1_IO_POL_IO2_inv BIT(26)
+	u32 io_tri;
+	u32 dum4[2];
+
+	u32 ceu_ctl;				/* 0x100 */
+#define     TCON_CEU_CTL_ceu_en BIT(31)
+	u32 dum5[3];
+	u32 ceu_rr;
+	u32 ceu_rg;
+	u32 ceu_rb;
+	u32 ceu_rc;
+	u32 ceu_gr;
+	u32 ceu_gg;
+	u32 ceu_gb;
+	u32 ceu_gc;
+	u32 ceu_br;
+	u32 ceu_bg;
+	u32 ceu_bb;
+	u32 ceu_bc;
+	u32 ceu_rv;
+	u32 ceu_gv;
+	u32 ceu_bv;
+	u32 dum6[45];
+
+	u32 mux_ctl;				/* 0x200 */
+#define		TCON_MUX_CTL_HDMI_SRC_SHIFT 8
+#define		TCON_MUX_CTL_HDMI_SRC_MASK GENMASK(9, 8)
+	u32 dum7[63];
+
+	u32 fill_ctl;				/* 0x300 */
+	u32 fill_start0;
+	u32 fill_end0;
+	u32 fill_data0;
+};
+
+#define XY(x, y) (((x) << 16) | (y))
+
+#define tcon_read(base, member) \
+	readl_relaxed(base + offsetof(struct tcon, member))
+#define tcon_write(base, member, data) \
+	writel_relaxed(data, base + offsetof(struct tcon, member))
+
+/*
+ * vertical blank functions
+ */
+static irqreturn_t de2_lcd_irq(int irq, void *dev_id)
+{
+	struct lcd *lcd = (struct lcd *) dev_id;
+	u32 isr;
+
+	isr = tcon_read(lcd->mmio, gint0);
+
+	drm_crtc_handle_vblank(&lcd->crtc);
+
+	tcon_write(lcd->mmio, gint0, isr & ~TCON_GINT0_TCON1_Vb_Int_Flag);
+
+	return IRQ_HANDLED;
+}
+
+int de2_enable_vblank(struct drm_device *drm, unsigned crtc)
+{
+	struct priv *priv = drm->dev_private;
+	struct lcd *lcd = priv->lcds[crtc];
+
+	tcon_write(lcd->mmio, gint0,
+			tcon_read(lcd->mmio, gint0) |
+					TCON_GINT0_TCON1_Vb_Int_En);
+	return 0;
+}
+
+void de2_disable_vblank(struct drm_device *drm, unsigned crtc)
+{
+	struct priv *priv = drm->dev_private;
+	struct lcd *lcd = priv->lcds[crtc];
+
+	tcon_write(lcd->mmio, gint0,
+			 tcon_read(lcd->mmio, gint0) &
+					~TCON_GINT0_TCON1_Vb_Int_En);
+}
+
+static void de2_set_frame_timings(struct lcd *lcd)
+{
+	struct drm_crtc *crtc = &lcd->crtc;
+	const struct drm_display_mode *mode = &crtc->mode;
+	int interlace = mode->flags & DRM_MODE_FLAG_INTERLACE ? 2 : 1;
+	int start_delay;
+	u32 data;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	data = XY(mode->hdisplay - 1, mode->vdisplay / interlace - 1);
+	tcon_write(lcd->mmio, basic0, data);
+	tcon_write(lcd->mmio, basic1, data);
+	tcon_write(lcd->mmio, basic2, data);
+	tcon_write(lcd->mmio, basic3,
+			XY(mode->htotal - 1,
+				mode->htotal - mode->hsync_start - 1));
+	tcon_write(lcd->mmio, basic4,
+			XY(mode->vtotal * (3 - interlace),
+				mode->vtotal - mode->vsync_start - 1));
+	tcon_write(lcd->mmio, basic5,
+			 XY(mode->hsync_end - mode->hsync_start - 1,
+				mode->vsync_end - mode->vsync_start - 1));
+
+	tcon_write(lcd->mmio, ps_sync, XY(1, 1));
+
+	data = TCON1_IO_POL_IO2_inv;
+	if (mode->flags & DRM_MODE_FLAG_PVSYNC)
+		data |= TCON1_IO_POL_IO0_inv;
+	if (mode->flags & DRM_MODE_FLAG_PHSYNC)
+		data |= TCON1_IO_POL_IO1_inv;
+	tcon_write(lcd->mmio, io_pol, data);
+
+	tcon_write(lcd->mmio, ceu_ctl,
+		tcon_read(lcd->mmio, ceu_ctl) & ~TCON_CEU_CTL_ceu_en);
+
+	data = tcon_read(lcd->mmio, tcon1_ctl);
+	if (interlace == 2)
+		data |= TCON1_CTL_Interlace_En;
+	else
+		data &= ~TCON1_CTL_Interlace_En;
+	tcon_write(lcd->mmio, tcon1_ctl, data);
+
+	tcon_write(lcd->mmio, fill_ctl, 0);
+	tcon_write(lcd->mmio, fill_start0, mode->vtotal + 1);
+	tcon_write(lcd->mmio, fill_end0, mode->vtotal);
+	tcon_write(lcd->mmio, fill_data0, 0);
+
+	start_delay = (mode->vtotal - mode->vdisplay) / interlace - 5;
+	if (start_delay > 31)
+		start_delay = 31;
+	data = tcon_read(lcd->mmio, tcon1_ctl);
+	data &= ~TCON1_CTL_Start_Delay_MASK;
+	data |= start_delay << TCON1_CTL_Start_Delay_SHIFT;
+	tcon_write(lcd->mmio, tcon1_ctl, data);
+
+	tcon_write(lcd->mmio, io_tri, 0x0fffffff);
+}
+
+static void de2_crtc_enable(struct drm_crtc *crtc)
+{
+	struct lcd *lcd = crtc_to_lcd(crtc);
+	struct drm_display_mode *mode = &crtc->mode;
+	u32 data;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	clk_set_rate(lcd->clk, mode->clock * 1000);
+
+	de2_set_frame_timings(lcd);
+
+//test 16-07-09 moved above 
+//	clk_set_rate(lcd->clk, mode->clock * 1000);
+
+	/* set the HDMI link */
+	data = tcon_read(lcd->mmio, mux_ctl);
+	data &= ~TCON_MUX_CTL_HDMI_SRC_MASK;
+	data |= lcd->num << TCON_MUX_CTL_HDMI_SRC_SHIFT;
+	tcon_write(lcd->mmio, mux_ctl, data);
+
+	tcon_write(lcd->mmio, tcon1_ctl,
+		tcon_read(lcd->mmio, tcon1_ctl) | TCON1_CTL_TCON_En);
+
+	de2_de_panel_init(lcd->priv, lcd->num, mode);
+
+	drm_mode_debug_printmodeline(mode);
+}
+
+static void de2_crtc_disable(struct drm_crtc *crtc)
+{
+	struct lcd *lcd = crtc_to_lcd(crtc);
+	unsigned long flags;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	tcon_write(lcd->mmio, tcon1_ctl,
+		tcon_read(lcd->mmio, tcon1_ctl) & ~TCON1_CTL_TCON_En);
+
+	if (crtc->state->event && !crtc->state->active) {
+		spin_lock_irqsave(&crtc->dev->event_lock, flags);
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+		crtc->state->event = NULL;
+	}
+}
+
+static const struct drm_crtc_funcs de2_crtc_funcs = {
+	.destroy	= drm_crtc_cleanup,
+	.set_config	= drm_atomic_helper_set_config,
+	.page_flip	= drm_atomic_helper_page_flip,
+	.reset		= drm_atomic_helper_crtc_reset,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+};
+
+static const struct drm_crtc_helper_funcs de2_crtc_helper_funcs = {
+	.enable		= de2_crtc_enable,
+	.disable	= de2_crtc_disable,
+};
+
+static void de2_tcon_init(struct lcd *lcd)
+{
+	tcon_write(lcd->mmio, tcon0_ctl,
+		tcon_read(lcd->mmio, tcon0_ctl) & ~TCON0_CTL_TCON_En);
+	tcon_write(lcd->mmio, tcon1_ctl,
+		tcon_read(lcd->mmio, tcon1_ctl) & ~TCON1_CTL_TCON_En);
+	tcon_write(lcd->mmio, gctl,
+		tcon_read(lcd->mmio, gctl) & ~TCON_GCTL_TCON_En);
+
+	/* disable/ack interrupts */
+	tcon_write(lcd->mmio, gint0, 0);
+}
+
+static void de2_tcon_enable(struct lcd *lcd)
+{
+//test
+	DRM_DEBUG_DRIVER("\n");
+	tcon_write(lcd->mmio, gctl,
+		tcon_read(lcd->mmio, gctl) | TCON_GCTL_TCON_En);
+}
+
+static int de2_crtc_init(struct drm_device *drm, struct lcd *lcd)
+{
+	struct drm_crtc *crtc = &lcd->crtc;
+	int ret;
+
+	ret = de2_plane_init(drm, lcd);
+	if (ret < 0)
+		return ret;
+
+	/* fixme: only one UI in LCD 1, so, no cursor... */
+	ret = drm_crtc_init_with_planes(drm, crtc,
+					&lcd->planes[DE2_PRIMARY_PLANE],
+					lcd->num == 0 ?
+						&lcd->planes[DE2_CURSOR_PLANE] :
+						NULL,
+					&de2_crtc_funcs, NULL);
+	if (ret < 0)
+		return ret;
+
+	de2_tcon_enable(lcd);
+
+	de2_de_enable(lcd->priv, lcd->num);
+
+	drm_crtc_helper_add(crtc, &de2_crtc_helper_funcs);
+
+	return 0;
+}
+
+/*
+ * device init
+ */
+static int de2_lcd_bind(struct device *dev, struct device *master,
+			void *data)
+{
+	struct drm_device *drm = data;
+	struct priv *priv = drm->dev_private;
+	struct lcd *lcd = dev_get_drvdata(dev);
+	int ret;
+
+	lcd->priv = priv;
+
+// hack: only 2 (N_LCDS) LCDs
+	if (!priv->lcds[0])
+		lcd->crtc_idx = 0;
+	else
+		lcd->crtc_idx = 1;
+	priv->lcds[lcd->crtc_idx] = lcd;
+
+	ret = de2_crtc_init(drm, lcd);
+	if (ret < 0) {
+		dev_err(dev, "failed to init the crtc\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void de2_lcd_unbind(struct device *dev, struct device *master,
+			void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct lcd *lcd = platform_get_drvdata(pdev);
+
+	if (lcd->mmio) {
+		if (lcd->priv)
+			de2_de_disable(lcd->priv, lcd->num);
+		tcon_write(lcd->mmio, gctl,
+			tcon_read(lcd->mmio, gctl) & ~TCON_GCTL_TCON_En);
+	}
+}
+
+static const struct component_ops de2_lcd_ops = {
+	.bind = de2_lcd_bind,
+	.unbind = de2_lcd_unbind,
+};
+
+static int de2_lcd_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node, *tmp, *parent, *port;
+	struct lcd *lcd;
+	struct resource *res;
+	int id, irq, ret;
+
+	id = of_alias_get_id(np, "lcd");
+	if (id < 0) {
+		dev_err(dev, "no alias for lcd\n");
+		id = 0;
+	}
+	lcd = devm_kzalloc(dev, sizeof *lcd, GFP_KERNEL);
+	if (!lcd) {
+		dev_err(dev, "failed to allocate private data\n");
+		return -ENOMEM;
+	}
+	dev_set_drvdata(dev, lcd);
+	lcd->dev = dev;
+	lcd->num = id;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "failed to get memory resource\n");
+		return -EINVAL;
+	}
+
+	lcd->mmio = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lcd->mmio)) {
+		dev_err(dev, "failed to map registers\n");
+		return PTR_ERR(lcd->mmio);
+	}
+
+	snprintf(lcd->name, sizeof(lcd->name), "sunxi-lcd%d", id);
+
+	/* possible CRTCs */
+	parent = np;
+	tmp = of_get_child_by_name(np, "ports");
+	if (tmp)
+		parent = tmp;
+	port = of_get_child_by_name(parent, "port");
+	of_node_put(tmp);
+	if (!port) {
+		dev_err(dev, "no port node\n");
+		return -ENXIO;
+	}
+	lcd->crtc.port = port;
+
+#if 0
+	lcd->gate = devm_clk_get(dev, "gate");		/* optional */
+//	if (IS_ERR(lcd->gate)) {
+//		dev_err(dev, "gate clock err %d\n", (int) PTR_ERR(lcd->gate));
+//		ret = PTR_ERR(lcd->gate);
+//		goto err;
+//	}
+#endif
+
+	lcd->clk = devm_clk_get(dev, "clock");
+	if (IS_ERR(lcd->clk)) {
+		dev_err(dev, "video clock err %d\n", (int) PTR_ERR(lcd->clk));
+		ret = PTR_ERR(lcd->clk);
+		goto err;
+	}
+
+#if 0
+	lcd->rstc = devm_reset_control_get_optional(dev, NULL);
+//	if (IS_ERR(lcd->rstc)) {
+//		dev_err(dev, "reset controller err %d\n",
+//				(int) PTR_ERR(lcd->rstc));
+//		ret = PTR_ERR(lcd->rstc);
+//		goto err;
+//	}
+#endif
+
+	irq = irq_of_parse_and_map(np, 0);
+	if (irq <= 0 || irq == NO_IRQ) {
+		dev_err(dev, "unable to get irq lcd %d\n", id);
+		ret = -EINVAL;
+		goto err;
+	}
+
+#if 0
+	if (!IS_ERR(lcd->rstc)) {
+		ret = reset_control_deassert(lcd->rstc);
+		if (ret) {
+			dev_err(dev, "reset deassert err %d\n", ret);
+			goto err;
+		}
+	}
+
+	if (!IS_ERR(lcd->gate)) {
+		ret = clk_prepare_enable(lcd->gate);
+		if (ret)
+			goto err2;
+	}
+#endif
+
+	ret = clk_prepare_enable(lcd->clk);
+	if (ret)
+		goto err2;
+
+	de2_tcon_init(lcd);
+
+	ret = devm_request_irq(dev, irq, de2_lcd_irq, 0,
+				lcd->name, lcd);
+	if (ret < 0) {
+		dev_err(dev, "unable to request irq %d\n", irq);
+		goto err2;
+	}
+
+	return component_add(dev, &de2_lcd_ops);
+
+err2:
+#if 0
+	reset_control_assert(lcd->rstc);
+	clk_disable_unprepare(lcd->gate);
+#endif
+	clk_disable_unprepare(lcd->clk);
+err:
+	of_node_put(lcd->crtc.port);
+	return ret;
+}
+
+static int de2_lcd_remove(struct platform_device *pdev)
+{
+	struct lcd *lcd = platform_get_drvdata(pdev);
+
+	component_del(&pdev->dev, &de2_lcd_ops);
+
+#if 0
+	if (!IS_ERR_OR_NULL(lcd->rstc))
+		reset_control_assert(lcd->rstc);
+	clk_disable_unprepare(lcd->gate);
+#endif
+	clk_disable_unprepare(lcd->clk);
+	of_node_put(lcd->crtc.port);
+
+	return 0;
+}
+
+static const struct of_device_id de2_lcd_ids[] = {
+	{ .compatible = "allwinner,sun8i-h3-lcd", },
+	{ }
+};
+
+struct platform_driver de2_lcd_platform_driver = {
+	.probe = de2_lcd_probe,
+	.remove = de2_lcd_remove,
+	.driver = {
+		.name = "sun8i-h3-lcd",
+		.of_match_table = of_match_ptr(de2_lcd_ids),
+	},
+};
diff --git a/drivers/gpu/drm/sunxi/de2_crtc.h b/drivers/gpu/drm/sunxi/de2_crtc.h
new file mode 100644
index 0000000..c4467be
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_crtc.h
@@ -0,0 +1,65 @@
+#ifndef __DE2_CRTC_H__
+#define __DE2_CRTC_H__
+/*
+ * Copyright (C) 2016 Jean-Franois Moine
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <drm/drm_plane_helper.h>
+
+struct priv;
+
+enum de2_plane2 {
+	DE2_VI_PLANE,
+	DE2_PRIMARY_PLANE,
+	DE2_CURSOR_PLANE,
+	DE2_N_PLANES,
+};
+struct lcd {
+	void __iomem *mmio;
+
+	struct device *dev;
+	struct drm_crtc crtc;
+	struct priv *priv;	/* DRM/DE private data */
+
+	short num;		/* LCD number in hardware */
+	short crtc_idx;		/* CRTC index in drm */
+
+	struct clk *clk;
+#if 0
+	struct clk *gate;
+	struct reset_control *rstc;
+#endif
+
+	char name[16];
+
+	struct drm_pending_vblank_event *event;
+
+	struct drm_plane planes[DE2_N_PLANES];
+};
+
+#define crtc_to_lcd(x) container_of(x, struct lcd, crtc)
+
+/* in de2_de.c */
+void de2_de_enable(struct priv *priv, int lcd_num);
+void de2_de_disable(struct priv *priv, int lcd_num);
+void de2_de_hw_init(struct priv *priv, int lcd_num);
+void de2_de_panel_init(struct priv *priv, int lcd_num,
+			struct drm_display_mode *mode);
+void de2_de_plane_disable(struct priv *priv,
+			int lcd_num, int plane_ix);
+void de2_de_plane_update(struct priv *priv,
+			int lcd_num, int plane_ix,
+			struct drm_plane_state *state,
+			struct drm_plane_state *old_state);
+
+/* in de2_plane.c */
+int de2_plane_init(struct drm_device *drm, struct lcd *lcd);
+
+#endif /* __DE2_CRTC_H__ */
diff --git a/drivers/gpu/drm/sunxi/de2_de.c b/drivers/gpu/drm/sunxi/de2_de.c
new file mode 100644
index 0000000..11f1fc9
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_de.c
@@ -0,0 +1,633 @@
+/*
+ * ALLWINNER DRM driver - Display Engine 2
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <asm/io.h>
+#include <drm/drm_gem_cma_helper.h>
+
+#include "de2_drm.h"
+#include "de2_crtc.h"
+
+static DEFINE_SPINLOCK(de_lock);
+
+#define DE_CLK_RATE_A83T 504000000	/* pll-de */
+#define DE_CLK_RATE_H3 432000000	/* de */
+
+/* I/O map */
+
+#define DE_MOD_REG 0x0000	/* 1 bit per LCD */
+#define DE_GATE_REG 0x0004
+#define DE_RESET_REG 0x0008
+#define DE_DIV_REG 0x000c	/* 4 bits per LCD */
+#define DE_SEL_REG 0x0010
+
+#define DE_MUX0_BASE 0x00100000
+#define DE_MUX1_BASE 0x00200000
+
+/* MUX registers (addr / MUX base) */
+#define DE_MUX_GLB_REGS 0x00000		/* global control */
+#define DE_MUX_BLD_REGS 0x01000		/* alpha blending */
+#define DE_MUX_CHAN_REGS 0x02000	/* VI/UI overlay channels */
+#define		DE_MUX_CHAN_SZ 0x1000	/* size of a channel */
+#define DE_MUX_VSU_REGS 0x20000		/* VSU */
+#define DE_MUX_GSU1_REGS 0x30000	/* GSUs */
+#define DE_MUX_GSU2_REGS 0x40000
+#define DE_MUX_GSU3_REGS 0x50000
+#define DE_MUX_FCE_REGS 0xa0000		/* FCE */
+#define DE_MUX_BWS_REGS 0xa2000		/* BWS */
+#define DE_MUX_LTI_REGS 0xa4000		/* LTI */
+#define DE_MUX_PEAK_REGS 0xa6000	/* PEAK */
+#define DE_MUX_ASE_REGS 0xa8000		/* ASE */
+#define DE_MUX_FCC_REGS 0xaa000		/* FCC */
+#define DE_MUX_DCSC_REGS 0xb0000	/* DCSC/SMBL */
+
+/* global control */
+struct de_glb {
+	u32 ctl;
+#define		DE_MUX_GLB_CTL_rt_en BIT(0)
+#define		DE_MUX_GLB_CTL_finish_irq_en BIT(4)
+#define		DE_MUX_GLB_CTL_rtwb_port BIT(12)
+	u32 status;
+	u32 dbuff;
+	u32 size;
+};
+
+/* alpha blending */
+struct de_bld {
+	u32 fcolor_ctl;			/* 00 */
+	struct {
+		u32 fcolor;
+		u32 insize;
+		u32 offset;
+		u32 dum;
+	} attr[4];
+	u32 dum0[15];			/* (end of clear offset) */
+	u32 route;			/* 80 */
+	u32 premultiply;
+	u32 bkcolor;
+	u32 output_size;
+	u32 bld_mode[4];
+	u32 dum1[4];
+	u32 ck_ctl;			/* b0 */
+//fixme: ck_mode << (clk_no * 4) - mode = (dir << 1) + en
+	u32 ck_cfg;
+//fixme: 7 << (clk_no * 8)
+	u32 dum2[2];
+	u32 ck_max[4];			/* c0 */
+//fixme fe0101
+	u32 dum3[4];
+	u32 ck_min[4];			/* e0 */
+//fixme fe0101
+	u32 dum4[3];
+	u32 out_ctl;			/* fc */
+};
+
+/* VI channel */
+struct de_vi {
+	struct {
+		u32 attr;
+#define			VI_CFG_ATTR_en BIT(0)
+#define			VI_CFG_ATTR_fcolor_en BIT(4)
+#define			VI_CFG_ATTR_fmt_SHIFT 8
+#define			VI_CFG_ATTR_fmt_MASK GENMASK(12, 8)
+#define			VI_CFG_ATTR_ui_sel BIT(15)
+#define			VI_CFG_ATTR_top_down BIT(23)
+		u32 size;
+		u32 coord;
+		u32 pitch[3];
+		u32 top_laddr[3];
+		u32 bot_laddr[3];
+	} cfg[4];
+	u32 fcolor[4];			/* c0 */
+	u32 top_haddr[3];		/* d0 */
+	u32 bot_haddr[3];		/* dc */
+	u32 ovl_size[2];		/* e8 */
+	u32 hori[2];			/* f0 */
+	u32 vert[2];			/* f8 */
+};
+
+/* UI channel */
+struct de_ui {
+	struct {
+		u32 attr;
+#define			UI_CFG_ATTR_en BIT(0)
+#define			UI_CFG_ATTR_alpmod_SHIFT 1
+#define			UI_CFG_ATTR_alpmod_MASK GENMASK(2, 1)
+#define			UI_CFG_ATTR_fcolor_en BIT(4)
+#define			UI_CFG_ATTR_fmt_SHIFT 8
+#define			UI_CFG_ATTR_fmt_MASK GENMASK(12, 8)
+#define			UI_CFG_ATTR_top_down BIT(23)
+#define			UI_CFG_ATTR_alpha_SHIFT 24
+#define			UI_CFG_ATTR_alpha_MASK GENMASK(31, 24)
+		u32 size;
+		u32 coord;
+		u32 pitch;
+		u32 top_laddr;
+		u32 bot_laddr;
+		u32 fcolor;
+		u32 dum;
+	} cfg[4];			/* 00 */
+	u32 top_haddr;			/* 80 */
+	u32 bot_haddr;
+	u32 ovl_size;			/* 88 */
+};
+
+/* coordinates and sizes */
+#define XY(x, y) (((y) << 16) | (x))
+#define WH(w, h) (((h - 1) << 16) | (w - 1))
+
+/* UI video formats */
+#define DE2_FORMAT_ARGB_8888 0
+#define DE2_FORMAT_XRGB_8888 4
+#define DE2_FORMAT_RGB_888 8
+#define DE2_FORMAT_BGR_888 9
+
+/* VI video formats */
+#define DE2_FORMAT_YUV422_I_YVYU 1
+#define DE2_FORMAT_YUV422_I_UYVY 2
+#define DE2_FORMAT_YUV422_I_YUYV 3
+#define DE2_FORMAT_YUV422_P 6
+#define DE2_FORMAT_YUV420_P 10
+
+#define glb_read(base, member) \
+	readl_relaxed(base + offsetof(struct de_glb, member))
+#define glb_write(base, member, data) \
+	writel_relaxed(data, base + offsetof(struct de_glb, member))
+#define bld_read(base, member) \
+	readl_relaxed(base + offsetof(struct de_bld, member))
+#define bld_write(base, member, data) \
+	writel_relaxed(data, base + offsetof(struct de_bld, member))
+#define ui_read(base, member) \
+	readl_relaxed(base + offsetof(struct de_ui, member))
+#define ui_write(base, member, data) \
+	writel_relaxed(data, base + offsetof(struct de_ui, member))
+#define vi_read(base, member) \
+	readl_relaxed(base + offsetof(struct de_vi, member))
+#define vi_write(base, member, data) \
+	writel_relaxed(data, base + offsetof(struct de_vi, member))
+
+static const struct {
+	char chan;
+	char layer;
+	char pipe;
+} plane2layer[DE2_N_PLANES] = {
+	[DE2_VI_PLANE] =	{0, 0, 2},
+	[DE2_PRIMARY_PLANE] =	{1, 0, 0},
+	[DE2_CURSOR_PLANE] =	{2, 0, 1},
+};
+
+static inline void de_write(struct priv *priv, int reg, u32 data)
+{
+	writel_relaxed(data, priv->mmio + reg);
+}
+
+static inline u32 de_read(struct priv *priv, int reg)
+{
+	return readl_relaxed(priv->mmio + reg);
+}
+
+static void de_lcd_select(struct priv *priv,
+			int lcd_num,
+			void __iomem *mux_o)
+{
+	u32 data;
+
+	/* select the LCD */
+	data = de_read(priv, DE_SEL_REG);
+#if 1 // test -> ok
+//fix: use lcd->idx (?)
+	data &= ~1;
+#else
+	if (lcd_num == 0)
+		data &= ~1;
+	else
+		data |= 1;
+#endif
+	de_write(priv, DE_SEL_REG, data);
+
+	/* double register switch */
+	glb_write(mux_o + DE_MUX_GLB_REGS, dbuff, 1);
+}
+
+void de2_de_plane_update(struct priv *priv,
+			int lcd_num, int plane_ix,
+			struct drm_plane_state *state,
+			struct drm_plane_state *old_state)
+{
+	struct drm_framebuffer *fb = state->fb;
+	struct drm_gem_cma_object *gem;
+	void __iomem *mux_o = priv->mmio;
+	void __iomem *chan_o;
+	u32 size = WH(state->crtc_w, state->crtc_h);
+	u32 coord = XY(state->crtc_x, state->crtc_y);
+	u32 screen_size;
+	u32 data, fcolor;
+	int chan, layer;
+	unsigned fmt, ui_sel, alpha_glob;
+	unsigned long flags;
+
+	mux_o += (lcd_num == 0) ? DE_MUX0_BASE : DE_MUX1_BASE;
+
+	chan = plane2layer[plane_ix].chan;
+	layer = plane2layer[plane_ix].layer;
+
+	chan_o = mux_o;
+	chan_o += DE_MUX_CHAN_REGS + DE_MUX_CHAN_SZ * chan;
+
+	/* handle the cursor move */
+	if (plane_ix == DE2_CURSOR_PLANE
+	 && fb == old_state->fb) {
+		spin_lock_irqsave(&de_lock, flags);
+		de_lcd_select(priv, lcd_num, mux_o);
+//		if (chan == 0)
+//			vi_write(chan_o, cfg[layer].coord, coord);
+//		else
+			ui_write(chan_o, cfg[layer].coord, coord);
+		spin_unlock_irqrestore(&de_lock, flags);
+		return;
+	}
+
+	gem = drm_fb_cma_get_gem_obj(fb, 0);
+
+#if 1
+//test overlay
+if (chan == 0 && vi_read(chan_o, cfg[layer].attr) == 0) {
+//	DRM_DEBUG_DRIVER("%d:%d %dx%d+%d+%d %.4s\n",
+	pr_info("%d:%d %dx%d+%d+%d %.4s\n",
+			lcd_num, plane_ix,
+			state->crtc_w, state->crtc_h,
+			state->crtc_x, state->crtc_y,
+			(char *) &fb->pixel_format);
+//pr_info("plane_update %d init\n", plane_ix);
+//print_hex_dump(KERN_INFO, "buf: ", DUMP_PREFIX_OFFSET,
+// 32, 1, gem->vaddr, 32, false);
+}
+#endif
+
+	ui_sel = alpha_glob = 0;
+	switch (fb->pixel_format) {
+	case DRM_FORMAT_ARGB8888:
+		fmt = DE2_FORMAT_ARGB_8888;
+		ui_sel = 1;
+		break;
+	case DRM_FORMAT_XRGB8888:
+		fmt = DE2_FORMAT_XRGB_8888;
+		ui_sel = 1;
+		alpha_glob = 1;
+		break;
+	case DRM_FORMAT_RGB888:
+		fmt = DE2_FORMAT_RGB_888;
+		ui_sel = 1;
+		break;
+	case DRM_FORMAT_BGR888:
+		fmt = DE2_FORMAT_BGR_888;
+		ui_sel = 1;
+		break;
+	case DRM_FORMAT_YUYV:
+		fmt = DE2_FORMAT_YUV422_I_YUYV;
+		break;
+	case DRM_FORMAT_YVYU:
+		fmt = DE2_FORMAT_YUV422_I_YVYU;
+		break;
+	case DRM_FORMAT_YUV422:
+		fmt = DE2_FORMAT_YUV422_P;
+		break;
+	case DRM_FORMAT_YUV420:
+		fmt = DE2_FORMAT_YUV420_P;
+		break;
+	case DRM_FORMAT_UYVY:
+		fmt = DE2_FORMAT_YUV422_I_UYVY;
+		break;
+	default:
+		pr_err("format %.4s not yet treated\n",
+			(char *) &fb->pixel_format);
+		return;
+	}
+
+	spin_lock_irqsave(&de_lock, flags);
+
+	if (plane_ix == DE2_PRIMARY_PLANE)
+		screen_size = size;
+	else
+		screen_size = glb_read(mux_o + DE_MUX_GLB_REGS, size);
+
+	/* prepare the activation of alpha blending (1 bit per plane) */
+	fcolor = bld_read(mux_o + DE_MUX_BLD_REGS, fcolor_ctl)
+			| (0x100 << plane2layer[plane_ix].pipe);
+
+	de_lcd_select(priv, lcd_num, mux_o);
+
+	if (chan == 0) {
+		int i, num_planes;
+
+		/* VI channel */
+		data = VI_CFG_ATTR_en | (fmt << VI_CFG_ATTR_fmt_SHIFT);
+		if (ui_sel)
+			data |= VI_CFG_ATTR_ui_sel;
+		vi_write(chan_o, cfg[layer].attr, data);
+		vi_write(chan_o, cfg[layer].size, size);
+		vi_write(chan_o, cfg[layer].coord, coord);
+//test
+//		num_planes = drm_format_num_planes(fb->pixel_format);
+ num_planes = 3;
+		for (i = 0; i < num_planes; i++) {
+			vi_write(chan_o, cfg[layer].pitch[i],
+					fb->pitches[i] ? fb->pitches[i] :
+							fb->pitches[0]);
+			vi_write(chan_o, cfg[layer].top_laddr[i],
+				gem->paddr + fb->offsets[i]);
+			vi_write(chan_o, fcolor[layer], 0xff000000);
+		}
+		vi_write(chan_o, ovl_size[0], screen_size);
+	} else {
+
+		/* UI channel */
+		data = UI_CFG_ATTR_en | (fmt << UI_CFG_ATTR_fmt_SHIFT);
+		if (alpha_glob)
+			data |= (1 << UI_CFG_ATTR_alpmod_SHIFT) |
+				(0xff << UI_CFG_ATTR_alpha_SHIFT);
+		ui_write(chan_o, cfg[layer].attr, data);
+		ui_write(chan_o, cfg[layer].size, size);
+		ui_write(chan_o, cfg[layer].coord, coord);
+		ui_write(chan_o, cfg[layer].pitch, fb->pitches[0]);
+		ui_write(chan_o, cfg[layer].top_laddr,
+				gem->paddr + fb->offsets[0]);
+		ui_write(chan_o, ovl_size, screen_size);
+	}
+	bld_write(mux_o + DE_MUX_BLD_REGS, fcolor_ctl, fcolor);
+
+	spin_unlock_irqrestore(&de_lock, flags);
+}
+
+void de2_de_plane_disable(struct priv *priv,
+			int lcd_num, int plane_ix)
+{
+	void __iomem *mux_o = priv->mmio;
+	void __iomem *chan_o;
+	u32 fcolor;
+	int chan, layer;
+	unsigned long flags;
+
+	chan = plane2layer[plane_ix].chan;
+	layer = plane2layer[plane_ix].layer;
+
+	mux_o += (lcd_num == 0) ? DE_MUX0_BASE : DE_MUX1_BASE;
+	chan_o = mux_o + DE_MUX_CHAN_REGS + DE_MUX_CHAN_SZ * chan;
+
+	spin_lock_irqsave(&de_lock, flags);
+
+	fcolor = bld_read(mux_o + DE_MUX_BLD_REGS, fcolor_ctl)
+			& ~(0x100 << plane2layer[plane_ix].pipe);
+	de_lcd_select(priv, lcd_num, mux_o);
+
+	/* (the VI and UI 'attr's are at the same offset) */
+	vi_write(chan_o, cfg[layer].attr, 0);
+	bld_write(mux_o + DE_MUX_BLD_REGS, fcolor_ctl, fcolor);
+
+	spin_unlock_irqrestore(&de_lock, flags);
+}
+
+void de2_de_panel_init(struct priv *priv, int lcd_num,
+			struct drm_display_mode *mode)
+{
+	void __iomem *mux_o = priv->mmio;
+	u32 size = WH(mode->hdisplay, mode->vdisplay);
+	unsigned i;
+	unsigned long flags;
+
+	mux_o += (lcd_num == 0) ? DE_MUX0_BASE : DE_MUX1_BASE;
+
+	DRM_DEBUG_DRIVER("%dx%d\n", mode->hdisplay, mode->vdisplay);
+
+	spin_lock_irqsave(&de_lock, flags);
+
+	de_lcd_select(priv, lcd_num, mux_o);
+
+	glb_write(mux_o + DE_MUX_GLB_REGS, size, size);
+
+	/* set alpha blending */
+	for (i = 0; i < 4; i++) {
+// from FriendlyARM
+		bld_write(mux_o + DE_MUX_BLD_REGS, attr[i].fcolor, 0xff000000);
+		bld_write(mux_o + DE_MUX_BLD_REGS, attr[i].insize, size);
+	}
+	bld_write(mux_o + DE_MUX_BLD_REGS, output_size, size);
+	bld_write(mux_o + DE_MUX_BLD_REGS, out_ctl,
+			mode->flags & DRM_MODE_FLAG_INTERLACE ? 2 : 0);
+
+	spin_unlock_irqrestore(&de_lock, flags);
+}
+
+void de2_de_enable(struct priv *priv, int lcd_num)
+{
+	void __iomem *mux_o = priv->mmio;
+	unsigned chan;
+	u32 size = WH(1920, 1080);
+	u32 data;
+	unsigned long flags;
+
+	DRM_DEBUG_DRIVER("lcd %d\n", lcd_num);
+//test
+//pr_info("de_enable lcd %d\n", lcd_num);
+
+#if 0 // moved to probe
+	/* set the A83T clock divider = 500 / 250 */
+	if (priv->soc_type == SOC_A83T) {
+		data = de_read(priv, DE_DIV_REG);
+//fixme: should div for both lcd0 and 1 ...
+		data &= ~(0x0f << lcd_num * 4);
+		data |= 1 << lcd_num * 4;		/* div = 2 */
+		de_write(priv, DE_DIV_REG, data);
+	}
+#endif
+
+	de_write(priv, DE_RESET_REG,
+			de_read(priv, DE_RESET_REG) |
+				(lcd_num == 0 ? 1 : 4));
+	data = 1 << lcd_num;			/* 1 bit / lcd */
+	de_write(priv, DE_GATE_REG,
+			de_read(priv, DE_GATE_REG) | data);
+	de_write(priv, DE_MOD_REG,
+			de_read(priv, DE_MOD_REG) | data);
+
+	mux_o += (lcd_num == 0) ? DE_MUX0_BASE : DE_MUX1_BASE;
+
+	spin_lock_irqsave(&de_lock, flags);
+
+	/* select the LCD */
+	data = de_read(priv, DE_SEL_REG);
+	if (lcd_num == 0)
+		data &= ~1;
+	else
+		data |= 1;
+	de_write(priv, DE_SEL_REG, data);
+
+	/* start init */
+	glb_write(mux_o + DE_MUX_GLB_REGS, ctl,
+		DE_MUX_GLB_CTL_rt_en | DE_MUX_GLB_CTL_rtwb_port);
+	glb_write(mux_o + DE_MUX_GLB_REGS, status, 0);
+	glb_write(mux_o + DE_MUX_GLB_REGS, dbuff, 1);	/* dble reg switch */
+	glb_write(mux_o + DE_MUX_GLB_REGS, size, size);
+
+	/* clear the VI/UI channels */
+	for (chan = 0; chan < 4; chan++) {
+		void __iomem *chan_o = mux_o + DE_MUX_CHAN_REGS +
+				DE_MUX_CHAN_SZ * chan;
+
+		memset_io(chan_o, 0, chan == 0 ?
+				sizeof(struct de_vi) : sizeof(struct de_ui));
+
+		/* only 1 VI and 1 UI in lcd1 */
+		if (chan == 2 && lcd_num == 1)
+			break;
+	}
+
+	/* clear and set alpha blending */
+	memset_io(mux_o + DE_MUX_BLD_REGS, 0, offsetof(struct de_bld, dum0));
+//test
+//pr_info("de_init suite\n");
+	bld_write(mux_o + DE_MUX_BLD_REGS, fcolor_ctl, 0x00000101);
+						/* fcolor for primary */
+	bld_write(mux_o + DE_MUX_BLD_REGS, route, 0x0021);
+					/* prepare route primary and cursor */
+	bld_write(mux_o + DE_MUX_BLD_REGS, premultiply, 0);
+	bld_write(mux_o + DE_MUX_BLD_REGS, bkcolor, 0xff000000);
+//16-02-07 uncommented for bad cursor - no change
+	bld_write(mux_o + DE_MUX_BLD_REGS, output_size, size);
+	bld_write(mux_o + DE_MUX_BLD_REGS, bld_mode[0], 0x03010301);
+								/* SRCOVER */
+	bld_write(mux_o + DE_MUX_BLD_REGS, bld_mode[1], 0x03010301);
+	bld_write(mux_o + DE_MUX_BLD_REGS, bld_mode[2], 0x03010301);
+	bld_write(mux_o + DE_MUX_BLD_REGS, out_ctl, 0);
+
+//test
+//pr_info("de_init no pb up to here\n");
+	/* disable the enhancements */
+	writel_relaxed(0, mux_o + DE_MUX_VSU_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_GSU1_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_GSU2_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_GSU3_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_FCE_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_BWS_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_LTI_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_PEAK_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_ASE_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_FCC_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_DCSC_REGS);
+
+	spin_unlock_irqrestore(&de_lock, flags);
+}
+
+void de2_de_disable(struct priv *priv, int lcd_num)
+{
+	u32 data;
+
+	data = ~(1 << lcd_num);
+	de_write(priv, DE_MOD_REG,
+			de_read(priv, DE_MOD_REG) & data);
+	de_write(priv, DE_GATE_REG,
+			de_read(priv, DE_GATE_REG) & data);
+	de_write(priv, DE_RESET_REG,
+			de_read(priv, DE_RESET_REG) & data);
+}
+
+int de2_de_init(struct priv *priv, struct device *dev)
+{
+	struct resource *res;
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	res = platform_get_resource(to_platform_device(dev),
+				IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "failed to get memory resource\n");
+		return -EINVAL;
+	}
+
+	priv->mmio = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->mmio)) {
+		dev_err(dev, "failed to map registers\n");
+		return PTR_ERR(priv->mmio);
+	}
+
+#if 0
+	priv->gate = devm_clk_get(dev, "gate");	/* optional */
+//	if (IS_ERR(priv->gate)) {
+//		dev_err(dev, "gate clock err %d\n", (int) PTR_ERR(priv->gate));
+//		return PTR_ERR(priv->gate);
+//	}
+#endif
+
+	priv->clk = devm_clk_get(dev, "clock");
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "video clock err %d\n", (int) PTR_ERR(priv->clk));
+		return PTR_ERR(priv->clk);
+	}
+
+#if 0
+	priv->rstc = devm_reset_control_get_optional(dev, NULL);
+//	if (IS_ERR(priv->rstc)) {
+//		dev_err(dev, "reset controller err %d\n",
+//				(int) PTR_ERR(priv->rstc));
+//		return PTR_ERR(priv->rstc);
+//	}
+
+	/* in order, do: de-assert, enable bus, enable clock */
+	if (!IS_ERR(priv->rstc)) {
+		ret = reset_control_deassert(priv->rstc);
+		if (ret) {
+			dev_err(dev, "reset deassert err %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (!IS_ERR(priv->gate)) {
+		ret = clk_prepare_enable(priv->gate);
+		if (ret)
+			goto err_gate;
+	}
+#endif
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		goto err_enable;
+	if (priv->soc_type == SOC_A83T)
+		clk_set_rate(priv->clk, DE_CLK_RATE_A83T);
+	else
+		clk_set_rate(priv->clk, DE_CLK_RATE_H3);
+
+#if 1 // moved from enable
+	/* set the A83T clock divider = 500 / 250 */
+	if (priv->soc_type == SOC_A83T)
+		de_write(priv, DE_DIV_REG,
+				0x00000011);	/* div = 2 for both LCDs */
+#endif
+
+	return 0;
+
+err_enable:
+#if 0
+	clk_disable_unprepare(priv->gate);
+err_gate:
+	if (!IS_ERR(priv->rstc))
+		reset_control_assert(priv->rstc);
+#endif
+	return ret;
+}
+
+void de2_de_cleanup(struct priv *priv)
+{
+	clk_disable_unprepare(priv->clk);
+#if 0
+	clk_disable_unprepare(priv->gate);
+	reset_control_assert(priv->rstc);
+#endif
+}
diff --git a/drivers/gpu/drm/sunxi/de2_drm.h b/drivers/gpu/drm/sunxi/de2_drm.h
new file mode 100644
index 0000000..80e3a9f
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_drm.h
@@ -0,0 +1,49 @@
+#ifndef __DE2_DRM_H__
+#define __DE2_DRM_H__
+/*
+ * Copyright (C) 2016 Jean-Franois Moine
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <drm/drmP.h>
+#include <drm/drm_fb_cma_helper.h>
+
+struct lcd;
+
+#define N_LCDS 2
+
+/* SoC types */
+#define SOC_A83T 0
+#define SOC_H3 1
+
+struct priv {
+	void __iomem *mmio;
+	struct clk *clk;
+#if 0
+	struct clk *gate;
+	struct reset_control *rstc;
+#endif
+
+	int soc_type;
+
+	struct drm_fbdev_cma *fbdev;
+
+	struct lcd *lcds[N_LCDS];
+};
+
+/* in de2_crtc.c */
+int de2_enable_vblank(struct drm_device *drm, unsigned crtc);
+void de2_disable_vblank(struct drm_device *drm, unsigned crtc);
+extern struct platform_driver de2_lcd_platform_driver;
+
+/* in de2_de.c */
+int de2_de_init(struct priv *priv, struct device *dev);
+void de2_de_cleanup(struct priv *priv);
+
+#endif /* __DE2_DRM_H__ */
diff --git a/drivers/gpu/drm/sunxi/de2_drv.c b/drivers/gpu/drm/sunxi/de2_drv.c
new file mode 100644
index 0000000..e8884247
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_drv.c
@@ -0,0 +1,390 @@
+/*
+ * Allwinner DRM driver - DE2 DRM driver
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/component.h>
+#include <drm/drm_of.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+
+#include "de2_drm.h"
+
+#define DRIVER_NAME	"sunxi-de2"
+#define DRIVER_DESC	"Allwinner DRM DE2"
+#define DRIVER_DATE	"20160601"
+#define DRIVER_MAJOR	1
+#define DRIVER_MINOR	0
+
+static struct of_device_id de2_drm_of_match[] = {
+	{ .compatible = "allwinner,sun8i-a83t-display-engine",
+				.data = (void *) SOC_A83T },
+	{ .compatible = "allwinner,sun8i-h3-display-engine",
+				.data = (void *) SOC_H3 },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, de2_drm_of_match);
+
+static void de2_fb_output_poll_changed(struct drm_device *drm)
+{
+	struct priv *priv = drm->dev_private;
+
+	if (priv->fbdev)
+		drm_fbdev_cma_hotplug_event(priv->fbdev);
+}
+
+static const struct drm_mode_config_funcs de2_mode_config_funcs = {
+	.fb_create = drm_fb_cma_create,
+	.output_poll_changed = de2_fb_output_poll_changed,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+/*
+ * DRM operations:
+ */
+static void de2_lastclose(struct drm_device *drm)
+{
+	struct priv *priv = drm->dev_private;
+
+	if (priv->fbdev)
+		drm_fbdev_cma_restore_mode(priv->fbdev);
+}
+
+static const struct file_operations de2_fops = {
+	.owner		= THIS_MODULE,
+	.open		= drm_open,
+	.release	= drm_release,
+	.unlocked_ioctl	= drm_ioctl,
+	.poll		= drm_poll,
+	.read		= drm_read,
+	.llseek		= no_llseek,
+	.mmap		= drm_gem_cma_mmap,
+};
+
+static struct drm_driver de2_drm_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_PRIME |
+					DRIVER_ATOMIC,
+	.lastclose		= de2_lastclose,
+//??
+	.get_vblank_counter	= drm_vblank_no_hw_counter,
+//warn on drm_irq.c:290
+//	.get_vblank_counter	= drm_vblank_count,
+	.enable_vblank		= de2_enable_vblank,
+	.disable_vblank		= de2_disable_vblank,
+	.gem_free_object	= drm_gem_cma_free_object,
+	.gem_vm_ops		= &drm_gem_cma_vm_ops,
+	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd,
+	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle,
+	.gem_prime_import	= drm_gem_prime_import,
+	.gem_prime_export	= drm_gem_prime_export,
+	.gem_prime_get_sg_table	= drm_gem_cma_prime_get_sg_table,
+	.gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table,
+	.gem_prime_vmap		= drm_gem_cma_prime_vmap,
+	.gem_prime_vunmap	= drm_gem_cma_prime_vunmap,
+	.gem_prime_mmap		= drm_gem_cma_prime_mmap,
+	.dumb_create		= drm_gem_cma_dumb_create,
+	.dumb_map_offset	= drm_gem_cma_dumb_map_offset,
+	.dumb_destroy		= drm_gem_dumb_destroy,
+	.fops			= &de2_fops,
+	.name			= DRIVER_NAME,
+	.desc			= DRIVER_DESC,
+	.date			= DRIVER_DATE,
+	.major			= DRIVER_MAJOR,
+	.minor			= DRIVER_MINOR,
+};
+
+#ifdef CONFIG_PM_SLEEP
+/*
+ * Power management
+ */
+static int de2_pm_suspend(struct device *dev)
+{
+	struct drm_device *drm = dev_get_drvdata(dev);
+
+	drm_kms_helper_poll_disable(drm);
+	return 0;
+}
+
+static int de2_pm_resume(struct device *dev)
+{
+	struct drm_device *drm = dev_get_drvdata(dev);
+
+	drm_kms_helper_poll_enable(drm);
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops de2_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(de2_pm_suspend, de2_pm_resume)
+};
+
+/*
+ * Platform driver
+ */
+
+static int de2_drm_bind(struct device *dev)
+{
+	struct drm_device *drm;
+	struct priv *priv;
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	drm = drm_dev_alloc(&de2_drm_driver, dev);
+	if (!drm)
+		return -ENOMEM;
+
+	ret = drm_dev_set_unique(drm, dev_name(dev));
+	if (ret < 0)
+		goto out1;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(dev, "failed to allocate private area\n");
+		ret = -ENOMEM;
+		goto out1;
+	}
+
+	dev_set_drvdata(dev, drm);
+	drm->dev_private = priv;
+
+	drm_mode_config_init(drm);
+	drm->mode_config.min_width = 32;	/* needed for cursor */
+	drm->mode_config.min_height = 32;
+	drm->mode_config.max_width = 1920;
+	drm->mode_config.max_height = 1080;
+	drm->mode_config.funcs = &de2_mode_config_funcs;
+
+	drm->irq_enabled = true;
+
+	ret = drm_dev_register(drm, 0);
+	if (ret < 0)
+		goto out2;
+
+	/* initialize the display engine */
+	priv->soc_type = (int) of_match_device(de2_drm_of_match, dev)->data;
+	ret = de2_de_init(priv, dev);
+	if (ret)
+		goto out3;
+
+	/* start the subdevices */
+	ret = component_bind_all(dev, drm);
+	if (ret < 0)
+		goto out3;
+
+	DRM_DEBUG_DRIVER("%d crtcs %d connectors\n",
+			 drm->mode_config.num_crtc,
+			 drm->mode_config.num_connector);
+
+	ret = drm_vblank_init(drm, drm->mode_config.num_crtc);
+	if (ret < 0)
+		dev_warn(dev, "failed to initialize vblank\n");
+
+	drm_mode_config_reset(drm);
+
+	priv->fbdev = drm_fbdev_cma_init(drm,
+					32,	/* bpp */
+					drm->mode_config.num_crtc,
+					drm->mode_config.num_connector);
+	if (IS_ERR(priv->fbdev)) {
+		ret = PTR_ERR(priv->fbdev);
+		priv->fbdev = NULL;
+		goto out4;
+	}
+
+	drm_kms_helper_poll_init(drm);
+
+	return 0;
+
+out4:
+	component_unbind_all(dev, drm);
+out3:
+	drm_dev_unregister(drm);
+out2:
+	kfree(priv);
+out1:
+	drm_dev_unref(drm);
+	return ret;
+}
+
+static void de2_drm_unbind(struct device *dev)
+{
+	struct drm_device *drm = dev_get_drvdata(dev);
+	struct priv *priv = drm->dev_private;
+
+	if (priv)
+		drm_fbdev_cma_fini(priv->fbdev);
+	drm_kms_helper_poll_fini(drm);
+
+//fixme: check again
+	component_unbind_all(dev, drm);
+
+	drm_dev_unregister(drm);
+	drm_vblank_cleanup(drm);
+
+	drm_mode_config_cleanup(drm);
+
+	if (priv) {
+		de2_de_cleanup(priv);
+		kfree(priv);
+	}
+
+	drm_dev_unref(drm);
+}
+
+static const struct component_master_ops de2_drm_comp_ops = {
+	.bind = de2_drm_bind,
+	.unbind = de2_drm_unbind,
+};
+
+static int compare_of(struct device *dev, void *data)
+{
+	return dev->of_node == data;
+}
+
+static int de2_drm_add_components(struct device *dev,
+				  int (*compare_of)(struct device *, void *),
+				  const struct component_master_ops *m_ops)
+{
+	struct device_node *ep, *port, *remote;
+	struct component_match *match = NULL;
+	int i;
+
+	if (!dev->of_node)
+		return -EINVAL;
+
+	/* bind the CRTCs */
+	for (i = 0; ; i++) {
+		port = of_parse_phandle(dev->of_node, "ports", i);
+		if (!port)
+			break;
+
+		if (!of_device_is_available(port->parent)) {
+			of_node_put(port);
+			continue;
+		}
+
+		component_match_add(dev, &match, compare_of, port->parent);
+		of_node_put(port);
+	}
+
+	if (i == 0) {
+		dev_err(dev, "missing 'ports' property\n");
+		return -ENODEV;
+	}
+	if (!match) {
+		dev_err(dev, "no available port\n");
+		return -ENODEV;
+	}
+
+	/* bind the encoders/connectors */
+	for (i = 0; ; i++) {
+		port = of_parse_phandle(dev->of_node, "ports", i);
+		if (!port)
+			break;
+
+		if (!of_device_is_available(port->parent)) {
+			of_node_put(port);
+			continue;
+		}
+
+		for_each_child_of_node(port, ep) {
+			remote = of_graph_get_remote_port_parent(ep);
+			if (!remote || !of_device_is_available(remote)) {
+				of_node_put(remote);
+				continue;
+			}
+			if (!of_device_is_available(remote->parent)) {
+				dev_warn(dev,
+					 "parent device of %s is not available\n",
+					 remote->full_name);
+				of_node_put(remote);
+				continue;
+			}
+
+			component_match_add(dev, &match, compare_of, remote);
+			of_node_put(remote);
+		}
+		of_node_put(port);
+	}
+
+	return component_master_add_with_match(dev, m_ops, match);
+}
+
+static int de2_drm_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = de2_drm_add_components(&pdev->dev,
+				     compare_of,
+				     &de2_drm_comp_ops);
+	if (ret == -EINVAL)
+		ret = -ENXIO;
+	return ret;
+}
+
+static int de2_drm_remove(struct platform_device *pdev)
+{
+	component_master_del(&pdev->dev, &de2_drm_comp_ops);
+
+	return 0;
+}
+
+static struct platform_driver de2_drm_platform_driver = {
+	.probe      = de2_drm_probe,
+	.remove     = de2_drm_remove,
+	.driver     = {
+		.name = "sun8i-de2",
+		.pm = &de2_pm_ops,
+		.of_match_table = de2_drm_of_match,
+	},
+};
+
+static int __init de2_drm_init(void)
+{
+	int ret;
+
+/* uncomment to activate the drm traces at startup time */
+/*	drm_debug = DRM_UT_CORE | DRM_UT_DRIVER | DRM_UT_KMS |
+			DRM_UT_PRIME | DRM_UT_ATOMIC; */
+//fixme: test
+//	drm_debug = DRM_UT_CORE | DRM_UT_DRIVER | DRM_UT_ATOMIC;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	ret = platform_driver_register(&de2_lcd_platform_driver);
+	if (ret < 0)
+		return ret;
+
+	ret = platform_driver_register(&de2_drm_platform_driver);
+	if (ret < 0)
+		platform_driver_unregister(&de2_lcd_platform_driver);
+
+	return ret;
+}
+
+static void __exit de2_drm_fini(void)
+{
+	platform_driver_unregister(&de2_lcd_platform_driver);
+	platform_driver_unregister(&de2_drm_platform_driver);
+}
+
+module_init(de2_drm_init);
+module_exit(de2_drm_fini);
+
+MODULE_AUTHOR("Jean-Francois Moine <moinejf@free.fr>");
+MODULE_DESCRIPTION("Allwinner DE2 DRM Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/sunxi/de2_plane.c b/drivers/gpu/drm/sunxi/de2_plane.c
new file mode 100644
index 0000000..14bb497
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_plane.c
@@ -0,0 +1,116 @@
+/*
+ * Allwinner DRM driver - DE2 planes
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_crtc_helper.h>
+
+#include "de2_drm.h"
+#include "de2_crtc.h"
+
+/* plane formats */
+static const uint32_t ui_formats[] = {
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888,
+};
+
+static const uint32_t vi_formats[] = {
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888,
+	DRM_FORMAT_YUYV,
+	DRM_FORMAT_YVYU,
+	DRM_FORMAT_YUV422,
+	DRM_FORMAT_YUV420,
+	DRM_FORMAT_UYVY,
+};
+
+static void de2_plane_disable(struct drm_plane *plane,
+				struct drm_plane_state *old_state)
+{
+	struct drm_crtc *crtc = old_state->crtc;
+	struct lcd *lcd = crtc_to_lcd(crtc);
+	int plane_num = plane - lcd->planes;
+
+	de2_de_plane_disable(lcd->priv, lcd->num, plane_num);
+}
+
+static void de2_plane_update(struct drm_plane *plane,
+				struct drm_plane_state *old_state)
+{
+	struct drm_plane_state *state = plane->state;
+	struct drm_crtc *crtc = state->crtc;
+	struct lcd *lcd = crtc_to_lcd(crtc);
+	struct drm_framebuffer *fb = state->fb;
+	int plane_num = plane - lcd->planes;
+
+	if (!crtc || !fb) {
+		DRM_DEBUG_DRIVER("no crtc/fb\n");
+		return;
+	}
+
+	de2_de_plane_update(lcd->priv, lcd->num, plane_num,
+			    state, old_state);
+}
+
+static const struct drm_plane_helper_funcs plane_helper_funcs = {
+	.atomic_disable = de2_plane_disable,
+	.atomic_update = de2_plane_update,
+};
+
+static const struct drm_plane_funcs plane_funcs = {
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
+	.destroy = drm_plane_cleanup,
+	.reset = drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+};
+
+static int de2_one_plane_init(struct drm_device *drm,
+				struct drm_plane *plane,
+				int type, int possible_crtcs,
+				const uint32_t *formats,
+				int nformats)
+{
+	int ret;
+
+	ret = drm_universal_plane_init(drm, plane, possible_crtcs,
+				&plane_funcs,
+				formats, nformats, type, NULL);
+	if (ret >= 0)
+		drm_plane_helper_add(plane, &plane_helper_funcs);
+
+	return ret;
+}
+
+int de2_plane_init(struct drm_device *drm, struct lcd *lcd)
+{
+	int ret, possible_crtcs = 1 << lcd->crtc_idx;
+
+	ret = de2_one_plane_init(drm, &lcd->planes[DE2_PRIMARY_PLANE],
+				DRM_PLANE_TYPE_PRIMARY, possible_crtcs,
+				ui_formats, ARRAY_SIZE(ui_formats));
+	if (ret >= 0 && lcd->num == 0)
+		ret = de2_one_plane_init(drm, &lcd->planes[DE2_CURSOR_PLANE],
+				DRM_PLANE_TYPE_CURSOR, possible_crtcs,
+				ui_formats, ARRAY_SIZE(ui_formats));
+	if (ret >= 0)
+		ret = de2_one_plane_init(drm, &lcd->planes[DE2_VI_PLANE],
+				DRM_PLANE_TYPE_OVERLAY, possible_crtcs,
+				vi_formats, ARRAY_SIZE(vi_formats));
+	if (ret < 0)
+		dev_err(lcd->dev, "Couldn't initialize the planes err %d\n",
+				ret);
+
+	return ret;
+}
diff --git a/drivers/pinctrl/sunxi/pinctrl-sun8i-a83t-r.c b/drivers/pinctrl/sunxi/pinctrl-sun8i-a83t-r.c
new file mode 100644
index 0000000..5bd18f1
--- /dev/null
+++ b/drivers/pinctrl/sunxi/pinctrl-sun8i-a83t-r.c
@@ -0,0 +1,118 @@
+/*
+ * Allwinner A83T SoCs special pins pinctrl driver.
+ *
+ * Copyright (C) 2016 Vishnu Patekar
+ * Vishnu Patekar <vishnupatekar0510@gmail.com>
+ *
+ * Based on pinctrl-sun8i-a23.c, which is:
+ * Copyright (C) 2014 Chen-Yu Tsai <wens@csie.org>
+ * Copyright (C) 2014 Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/reset.h>
+
+#include "pinctrl-sunxi.h"
+
+static const struct sunxi_desc_pin sun8i_a83t_r_pins[] = {
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 0),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_rsb"),		/* SCK */
+		  SUNXI_FUNCTION(0x3, "s_twi"),		/* SCK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 0)),	/* PL_EINT0 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 1),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_rsb"),		/* SDA */
+		  SUNXI_FUNCTION(0x3, "s_twi"),		/* SDA */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 1)),	/* PL_EINT1 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 2),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_uart"),	/* TX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 2)),	/* PL_EINT2 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 3),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_uart"),	/* RX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 3)),	/* PL_EINT3 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 4),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_jtag"),	/* MS */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 4)),	/* PL_EINT4 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 5),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_jtag"),	/* CK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 5)),	/* PL_EINT5 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 6),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_jtag"),	/* DO */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 6)),	/* PL_EINT6 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 7),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_jtag"),	/* DI */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 7)),	/* PL_EINT7 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 8),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_twi"),		/* SCK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 8)),	/* PL_EINT8 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 9),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_twi"),		/* SDA */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 9)),	/* PL_EINT9 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 10),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_pwm"),
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 10)),	/* PL_EINT10 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 11),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 11)),	/* PL_EINT11 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 12),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_cir"),		/* RX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 11)),	/* PL_EINT12 */
+};
+
+static const struct sunxi_pinctrl_desc sun8i_a83t_r_pinctrl_data = {
+	.pins = sun8i_a83t_r_pins,
+	.npins = ARRAY_SIZE(sun8i_a83t_r_pins),
+	.pin_base = PL_BASE,
+	.irq_banks = 1,
+};
+
+static int sun8i_a83t_r_pinctrl_probe(struct platform_device *pdev)
+{
+	return sunxi_pinctrl_init(pdev, &sun8i_a83t_r_pinctrl_data);
+}
+
+static const struct of_device_id sun8i_a83t_r_pinctrl_match[] = {
+	{ .compatible = "allwinner,sun8i-a83t-r-pinctrl", },
+	{}
+};
+
+static struct platform_driver sun8i_a83t_r_pinctrl_driver = {
+	.probe	= sun8i_a83t_r_pinctrl_probe,
+	.driver	= {
+		.name		= "sun8i-a83t-r-pinctrl",
+		.of_match_table	= sun8i_a83t_r_pinctrl_match,
+	},
+};
+module_platform_driver(sun8i_a83t_r_pinctrl_driver);
diff --git a/drivers/thermal/sun8i_ths.c b/drivers/thermal/sun8i_ths.c
new file mode 100644
index 0000000..5a9e346
--- /dev/null
+++ b/drivers/thermal/sun8i_ths.c
@@ -0,0 +1,478 @@
+/*
+ * Sunxi THS driver
+ *
+ * Copyright (C) 2015 Josef Gajdusek
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#if IS_ENABLED(CONFIG_NVMEM)
+#  include <linux/nvmem-consumer.h>
+#endif
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/thermal.h>
+
+/* common A83T/H3 */
+#define THS_H3_CTRL0			0x00
+#define THS_H3_CTRL1			0x04
+#define THS_H3_CDAT				0x14
+#define THS_H3_CTRL2			0x40
+#define THS_H3_INT_CTRL			0x44
+#define THS_H3_STAT				0x48
+#define THS_H3_ALARM_CTRL		0x50
+#define THS_A83T_ALARM_CTRL1		0x54
+#define THS_A83T_ALARM_CTRL2		0x58
+#define THS_H3_SHUTDOWN_CTRL		0x60
+#define THS_A83T_SHUTDOWN_CTRL1		0x64
+#define THS_A83T_SHUTDOWN_CTRL2		0x68
+#define THS_H3_FILTER			0x70
+#define THS_H3_CDATA			0x74
+#define THS2_A83T_CDATA			0x78
+#define THS_H3_DATA			0x80
+#define THS1_A83T_DATA			0x84
+#define THS2_A83T_DATA			0x88
+
+#define THS_H3_CTRL0_SENSOR_ACQ0_OFFS   0
+#define THS_H3_CTRL0_SENSOR_ACQ0(x) \
+	((x) << THS_H3_CTRL0_SENSOR_ACQ0_OFFS)
+#define THS_H3_CTRL1_ADC_CALI_EN_OFFS   17
+#define THS_H3_CTRL1_ADC_CALI_EN \
+	BIT(THS_H3_CTRL1_ADC_CALI_EN_OFFS)
+#define THS_H3_CTRL1_OP_BIAS_OFFS       20
+#define THS_H3_CTRL1_OP_BIAS(x) \
+	((x) << THS_H3_CTRL1_OP_BIAS_OFFS)
+#define THS_H3_CTRL2_SENSE_EN_OFFS      0
+#define THS_H3_CTRL2_SENSE_EN \
+	BIT(THS_H3_CTRL2_SENSE_EN_OFFS)
+#define THS_H3_CTRL2_SENSOR_ACQ1_OFFS   16
+#define THS_H3_CTRL2_SENSOR_ACQ1(x) \
+	((x) << THS_H3_CTRL2_SENSOR_ACQ1_OFFS)
+
+#define THS_H3_INT_CTRL_ALARM_INT_EN_OFFS       0
+#define THS_H3_INT_CTRL_ALARM_INT_EN \
+	BIT(THS_H3_INT_CTRL_ALARM_INT_EN_OFFS)
+#define THS_H3_INT_CTRL_SHUT_INT_EN_OFFS		4
+#define THS_H3_INT_CTRL_SHUT_INT_EN \
+	BIT(THS_H3_INT_CTRL_SHUT_INT_EN_OFFS)
+#define THS_H3_INT_CTRL_DATA_IRQ_EN_OFFS		8
+#define THS_H3_INT_CTRL_DATA_IRQ_EN \
+	BIT(THS_H3_INT_CTRL_DATA_IRQ_EN_OFFS)
+#define THS_H3_INT_CTRL_THERMAL_PER_OFFS		12
+#define THS_H3_INT_CTRL_THERMAL_PER(x) \
+	((x) << THS_H3_INT_CTRL_THERMAL_PER_OFFS)
+
+#define THS_H3_STAT_ALARM_INT_STS_OFFS  0
+#define THS_H3_STAT_ALARM_INT_STS \
+	BIT(THS_H3_STAT_ALARM_INT_STS_OFFS)
+#define THS_H3_STAT_SHUT_INT_STS_OFFS   4
+#define THS_H3_STAT_SHUT_INT_STS \
+	BIT(THS_H3_STAT_SHUT_INT_STS_OFFS)
+#define THS_H3_STAT_DATA_IRQ_STS_OFFS   8
+#define THS_H3_STAT_DATA_IRQ_STS \
+	BIT(THS_H3_STAT_DATA_IRQ_STS_OFFS)
+#define THS_H3_STAT_ALARM_OFF_STS_OFFS  12
+#define THS_H3_STAT_ALARM_OFF_STS \
+	BIT(THS_H3_STAT_ALARM_OFF_STS_OFFS)
+
+#define THS_H3_ALARM_CTRL_ALARM0_T_HYST_OFFS    0
+#define THS_H3_ALARM_CTRL_ALARM0_T_HYST(x) \
+	((x) << THS_H3_ALARM_CTRL_ALARM0_T_HYST_OFFS)
+#define THS_H3_ALARM_CTRL_ALARM0_T_HOT_OFFS     16
+#define THS_H3_ALARM_CTRL_ALARM0_T_HOT(x) \
+	((x) << THS_H3_ALARM_CTRL_ALARM0_T_HOT_OFFS)
+
+#define THS_H3_SHUTDOWN_CTRL_SHUT0_T_HOT_OFFS   16
+#define THS_H3_SHUTDOWN_CTRL_SHUT0_T_HOT(x) \
+	((x) << THS_H3_SHUTDOWN_CTRL_SHUT0_T_HOT_OFFS)
+
+#define THS_H3_FILTER_TYPE_OFFS 0
+#define THS_H3_FILTER_TYPE(x) \
+	((x) << THS_H3_FILTER_TYPE_OFFS)
+#define THS_H3_FILTER_EN_OFFS   2
+#define THS_H3_FILTER_EN \
+	BIT(THS_H3_FILTER_EN_OFFS)
+
+#define THS_A83T_CTRL0_SENSOR_ACQ0_VALUE	0x17
+#define THS_A83T_CTRL2_SENSOR_ACQ1_VALUE	0x17
+#define THS_A83T_CTRL2_SENSE_EN(x) \
+		((x) << THS_H3_CTRL2_SENSE_EN_OFFS)
+#define THS_A83T_INT_CTRL_ALARM_INT_EN(x) \
+		((x) << THS_H3_INT_CTRL_ALARM_INT_EN_OFFS)
+#define THS_A83T_INT_CTRL_THERMAL_PER_VALUE		0x00001
+#define THS_A83T_FILTER_TYPE_VALUE			0x1
+
+#define THS_H3_CTRL0_SENSOR_ACQ0_VALUE			0xff
+#define THS_H3_INT_CTRL_THERMAL_PER_VALUE		0x79
+#define THS_H3_FILTER_TYPE_VALUE				0x2
+#define THS_H3_CTRL2_SENSOR_ACQ1_VALUE			0x3f
+
+struct sun8i_ths_data {
+	struct sun8i_ths_type *type;
+	struct reset_control *reset;
+	struct clk *clk;
+//	struct clk *busclk;
+	void __iomem *regs;
+#if IS_ENABLED(CONFIG_NVMEM)
+	struct nvmem_cell *calcell;
+#endif
+	struct platform_device *pdev;
+	struct thermal_zone_device *tzd;
+};
+
+struct sun8i_ths_type {
+	int (*init)(struct platform_device *, struct sun8i_ths_data *);
+	int (*get_temp)(struct sun8i_ths_data *, int *out);
+	void (*irq)(struct sun8i_ths_data *);
+	void (*deinit)(struct sun8i_ths_data *);
+};
+
+/* Formula and parameters from the Allwinner 3.4 kernel */
+static int sun8i_ths_reg_to_temperature(s32 reg, int divisor, int constant)
+{
+	return constant - (reg * 1000000) / divisor;
+}
+
+static int sun8i_ths_get_temp(void *_data, int *out)
+{
+	struct sun8i_ths_data *data = _data;
+
+	return data->type->get_temp(data, out);
+}
+
+static irqreturn_t sun8i_ths_irq_thread(int irq, void *_data)
+{
+	struct sun8i_ths_data *data = _data;
+
+	data->type->irq(data);
+	thermal_zone_device_update(data->tzd);
+
+	return IRQ_HANDLED;
+}
+
+/* ----- A83T (sun8iw6p1) ----- */
+static int sun8i_ths_a83t_init(struct platform_device *pdev,
+			     struct sun8i_ths_data *data)
+{
+#if IS_ENABLED(CONFIG_NVMEM)
+	if (data->calcell) {
+		size_t callen;
+		s32 (*caldata)[];
+
+		caldata = nvmem_cell_read(data->calcell, &callen);
+		if (IS_ERR(caldata))
+			return PTR_ERR(caldata);
+		if ((*caldata)[0])
+			writel(be32_to_cpu((*caldata)[0]),
+				data->regs + THS_H3_CDATA);
+		if ((*caldata)[1])
+			writel(be32_to_cpu((*caldata)[1]),
+				data->regs + THS2_A83T_CDATA);
+		kfree(caldata);
+	}
+#endif
+
+	writel(THS_H3_CTRL0_SENSOR_ACQ0(THS_A83T_CTRL0_SENSOR_ACQ0_VALUE),
+	       data->regs + THS_H3_CTRL0);
+	writel(THS_H3_CTRL2_SENSOR_ACQ1(THS_A83T_CTRL2_SENSOR_ACQ1_VALUE) |
+			THS_A83T_CTRL2_SENSE_EN(7),
+	       data->regs + THS_H3_CTRL2);
+	writel(THS_H3_INT_CTRL_THERMAL_PER(THS_A83T_INT_CTRL_THERMAL_PER_VALUE) |
+			THS_A83T_INT_CTRL_ALARM_INT_EN(7),
+	       data->regs + THS_H3_INT_CTRL);
+	writel(THS_H3_FILTER_EN |
+			THS_H3_FILTER_TYPE(THS_A83T_FILTER_TYPE_VALUE),
+	       data->regs + THS_H3_FILTER);
+
+	return 0;
+}
+
+static int sun8i_ths_a83t_get_temp(struct sun8i_ths_data *data, int *out)
+{
+	int val = readl(data->regs + THS_H3_DATA);
+
+	*out = sun8i_ths_reg_to_temperature(val, 14186, 192000);
+	return 0;
+}
+
+static void sun8i_ths_a83t_irq(struct sun8i_ths_data *data)
+{
+	u32 status;
+
+	status = readl(data->regs + THS_H3_STAT);
+	writel(status, data->regs + THS_H3_STAT);
+}
+
+static void sun8i_ths_a83t_deinit(struct sun8i_ths_data *data)
+{
+}
+
+static const struct sun8i_ths_type sun8i_ths_device_a83t = {
+	.init = sun8i_ths_a83t_init,
+	.get_temp = sun8i_ths_a83t_get_temp,
+	.irq = sun8i_ths_a83t_irq,
+	.deinit = sun8i_ths_a83t_deinit,
+};
+
+/* ----- H3 (sun8iw7p1) ----- */
+static int sun8i_ths_h3_init(struct platform_device *pdev,
+			     struct sun8i_ths_data *data)
+{
+	int ret;
+
+#if 0
+	data->busclk = devm_clk_get(&pdev->dev, "ahb");
+	if (IS_ERR(data->busclk)) {
+		ret = PTR_ERR(data->busclk);
+		dev_err(&pdev->dev, "failed to get ahb clk: %d\n", ret);
+		return ret;
+	}
+#endif
+
+//	data->clk = devm_clk_get(&pdev->dev, "ths");
+	data->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(data->clk)) {
+		ret = PTR_ERR(data->clk);
+		dev_err(&pdev->dev, "failed to get ths clk: %d\n", ret);
+		return ret;
+	}
+
+	data->reset = devm_reset_control_get_optional(&pdev->dev, NULL);
+//	if (IS_ERR(data->reset)) {
+//		ret = PTR_ERR(data->reset);
+//		dev_err(&pdev->dev, "failed to get reset: %d\n", ret);
+//		return ret;
+//	}
+
+#if IS_ENABLED(CONFIG_NVMEM)
+	if (data->calcell) {
+		size_t callen;
+		s32 *caldata;
+
+		caldata = nvmem_cell_read(data->calcell, &callen);
+		if (IS_ERR(caldata))
+			return PTR_ERR(caldata);
+		if (*caldata)
+			writel(be32_to_cpu(*caldata),
+				data->regs + THS_H3_CDATA);
+		kfree(caldata);
+	}
+#endif
+
+#if 0
+	ret = clk_prepare_enable(data->busclk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable bus clk: %d\n", ret);
+		return ret;
+	}
+#endif
+
+	ret = clk_prepare_enable(data->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable ths clk: %d\n", ret);
+		goto err_disable_bus;
+	}
+
+	if (!IS_ERR(data->reset)) {
+		ret = reset_control_deassert(data->reset);
+		if (ret) {
+			dev_err(&pdev->dev, "reset deassert failed: %d\n", ret);
+			goto err_disable_ths;
+		}
+	}
+
+	/* The final sample period is calculated as follows:
+	 * (THERMAL_PER + 1) * 4096 / f_clk * 2^(FILTER_TYPE + 1)
+	 *
+	 * This results to about 1Hz with these settings.
+	 */
+	ret = clk_set_rate(data->clk, 4000000);
+	if (ret)
+		goto err_disable_ths;
+	writel(THS_H3_CTRL0_SENSOR_ACQ0(THS_H3_CTRL0_SENSOR_ACQ0_VALUE),
+	       data->regs + THS_H3_CTRL0);
+	writel(THS_H3_INT_CTRL_THERMAL_PER(THS_H3_INT_CTRL_THERMAL_PER_VALUE) |
+//jfm
+/*	       THS_H3_INT_CTRL_DATA_IRQ_EN, */
+		THS_H3_INT_CTRL_ALARM_INT_EN,
+	       data->regs + THS_H3_INT_CTRL);
+	writel(THS_H3_FILTER_EN | THS_H3_FILTER_TYPE(THS_H3_FILTER_TYPE_VALUE),
+	       data->regs + THS_H3_FILTER);
+	writel(THS_H3_CTRL2_SENSOR_ACQ1(THS_H3_CTRL2_SENSOR_ACQ1_VALUE) |
+	       THS_H3_CTRL2_SENSE_EN,
+	       data->regs + THS_H3_CTRL2);
+	return 0;
+
+err_disable_ths:
+	clk_disable_unprepare(data->clk);
+err_disable_bus:
+//	clk_disable_unprepare(data->busclk);
+
+	return ret;
+}
+
+static int sun8i_ths_h3_get_temp(struct sun8i_ths_data *data, int *out)
+{
+	int val = readl(data->regs + THS_H3_DATA);
+	*out = sun8i_ths_reg_to_temperature(val, 8253, 217000);
+	return 0;
+}
+
+#if 0
+static void sun8i_ths_h3_irq(struct sun8i_ths_data *data)
+{
+	writel(THS_H3_STAT_DATA_IRQ_STS |
+	       THS_H3_STAT_ALARM_INT_STS |
+	       THS_H3_STAT_ALARM_OFF_STS |
+	       THS_H3_STAT_SHUT_INT_STS,
+	       data->regs + THS_H3_STAT);
+}
+#endif
+
+static void sun8i_ths_h3_deinit(struct sun8i_ths_data *data)
+{
+	if (!IS_ERR(data->reset))
+		reset_control_assert(data->reset);
+	clk_disable_unprepare(data->clk);
+//	clk_disable_unprepare(data->busclk);
+}
+
+static const struct thermal_zone_of_device_ops sun8i_ths_thermal_ops = {
+	.get_temp = sun8i_ths_get_temp,
+};
+
+static const struct sun8i_ths_type sun8i_ths_device_h3 = {
+	.init = sun8i_ths_h3_init,
+	.get_temp = sun8i_ths_h3_get_temp,
+//	.irq = sun8i_ths_h3_irq,
+	.irq = sun8i_ths_a83t_irq,
+	.deinit = sun8i_ths_h3_deinit,
+};
+
+static const struct of_device_id sun8i_ths_id_table[] = {
+	{
+		.compatible = "allwinner,sun8i-h3-ths",
+		.data = &sun8i_ths_device_h3,
+	},
+	{
+		.compatible = "allwinner,sun8i-a83t-ths",
+		.data = &sun8i_ths_device_a83t,
+	},
+	{
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(of, sun8i_ths_id_table);
+
+static int sun8i_ths_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *match;
+	struct sun8i_ths_data *data;
+	struct resource *res;
+	int ret;
+	int irq;
+
+	match = of_match_node(sun8i_ths_id_table, np);
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->type = (struct sun8i_ths_type *)match->data;
+	data->pdev = pdev;
+
+#if IS_ENABLED(CONFIG_NVMEM)
+	data->calcell = devm_nvmem_cell_get(&pdev->dev, "calibration");
+	if (IS_ERR(data->calcell)) {
+		if (PTR_ERR(data->calcell) == -EPROBE_DEFER)
+			return PTR_ERR(data->calcell);
+		data->calcell = NULL; /* No calibration register */
+	}
+#endif
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(data->regs)) {
+		ret = PTR_ERR(data->regs);
+		dev_err(&pdev->dev,
+			"failed to ioremap THS registers: %d\n", ret);
+		return ret;
+	}
+
+//fixme: no interrupt in the A83T ??
+    if (data->type != &sun8i_ths_device_a83t) {
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "failed to get IRQ: %d\n", irq);
+		return irq;
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+					sun8i_ths_irq_thread, IRQF_ONESHOT,
+					dev_name(&pdev->dev), data);
+	if (ret)
+		return ret;
+    }
+
+	ret = data->type->init(pdev, data);
+	if (ret)
+		return ret;
+
+	data->tzd = thermal_zone_of_sensor_register(&pdev->dev, 0, data,
+						    &sun8i_ths_thermal_ops);
+	if (IS_ERR(data->tzd)) {
+		ret = PTR_ERR(data->tzd);
+		dev_err(&pdev->dev, "failed to register thermal zone: %d\n",
+			ret);
+		goto err_deinit;
+	}
+
+	platform_set_drvdata(pdev, data);
+	return 0;
+
+err_deinit:
+	data->type->deinit(data);
+	return ret;
+}
+
+static int sun8i_ths_remove(struct platform_device *pdev)
+{
+	struct sun8i_ths_data *data = platform_get_drvdata(pdev);
+
+	thermal_zone_of_sensor_unregister(&pdev->dev, data->tzd);
+	data->type->deinit(data);
+	return 0;
+}
+
+static struct platform_driver sun8i_ths_driver = {
+	.probe = sun8i_ths_probe,
+	.remove = sun8i_ths_remove,
+	.driver = {
+		.name = "sun8i_ths",
+		.of_match_table = sun8i_ths_id_table,
+	},
+};
+
+module_platform_driver(sun8i_ths_driver);
+
+MODULE_AUTHOR("Josef Gajdusek <atx@xxxxxxxx>");
+MODULE_DESCRIPTION("Sunxi THS driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/dt-bindings/clock/sun8i-a83t.h b/include/dt-bindings/clock/sun8i-a83t.h
new file mode 100644
index 0000000..c063783
--- /dev/null
+++ b/include/dt-bindings/clock/sun8i-a83t.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Based on the H3 version from
+ * Copyright (C) 2016 Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DT_BINDINGS_CLK_SUN8I_A83T_H_
+#define _DT_BINDINGS_CLK_SUN8I_A83T_H_
+
+#define CLK_BUS_DMA		0
+#define CLK_BUS_EHCI0		1
+#define CLK_BUS_EHCI1		2
+#define CLK_BUS_MMC0		3
+#define CLK_BUS_MMC1		4
+#define CLK_BUS_MMC2		5
+#define CLK_BUS_OHCI0		6
+#define CLK_BUS_PIO		7
+#define CLK_BUS_UART0		8
+#define CLK_BUS_UART1		9
+#define CLK_BUS_UART2		10
+#define CLK_BUS_UART3		11
+#define CLK_BUS_UART4		12
+#define CLK_BUS_USBDRD		13
+#define CLK_DAUDIO0		14
+#define CLK_DAUDIO1		15
+#define CLK_DAUDIO2		16
+#define CLK_HDMI		17
+#define CLK_HDMI_DDC		18
+#define CLK_MMC0		19
+#define CLK_MMC0_SAMPLE		20
+#define CLK_MMC0_OUTPUT		21
+#define CLK_MMC1		22
+#define CLK_MMC1_SAMPLE		23
+#define CLK_MMC1_OUTPUT		24
+#define CLK_MMC2		25
+#define CLK_MMC2_SAMPLE		26
+#define CLK_MMC2_OUTPUT		27
+#define CLK_OHCI0		28
+#define CLK_OSC12M		29
+#define CLK_PLL_AUDIO		30
+#define CLK_PLL_DE		31
+#define CLK_PLL_GPU		32
+#define CLK_PLL_HSIC		33
+#define CLK_PLL_PERIPH		34
+#define CLK_PLL_VE		35
+#define CLK_PLL_VIDEO0		36
+#define CLK_PLL_VIDEO1		37
+#define CLK_SPDIF		38
+#define CLK_SPI0		39
+#define CLK_SPI1		40
+#define CLK_TCON0		41
+#define CLK_TCON1		42
+#define CLK_TDM			43
+#define CLK_USB_PHY0		44
+#define CLK_USB_PHY1		45
+#define CLK_USB_HSIC		46
+#define CLK_VE			47
+
+#endif /* _DT_BINDINGS_CLK_SUN8I_A83T_H_ */
diff --git a/include/dt-bindings/clock/sun8i-h3.h b/include/dt-bindings/clock/sun8i-h3.h
new file mode 100644
index 0000000..372a2b7
--- /dev/null
+++ b/include/dt-bindings/clock/sun8i-h3.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2016 Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DT_BINDINGS_CLK_SUN8I_H3_H_
+#define _DT_BINDINGS_CLK_SUN8I_H3_H_
+
+#define CLK_BUS_DMA		0
+#define CLK_BUS_EHCI0		1
+#define CLK_BUS_EHCI1		2
+#define CLK_BUS_EHCI2		3
+#define CLK_BUS_EHCI3		4
+#define CLK_BUS_MMC0		5
+#define CLK_BUS_MMC1		6
+#define CLK_BUS_MMC2		7
+#define CLK_BUS_OHCI0		8
+#define CLK_BUS_OHCI1		9
+#define CLK_BUS_OHCI2		10
+#define CLK_BUS_OHCI3		11
+#define CLK_BUS_PIO		12
+#define CLK_BUS_UART0		13
+#define CLK_BUS_UART1		14
+#define CLK_BUS_UART2		15
+#define CLK_BUS_UART3		16
+#define CLK_DE			17
+#define CLK_HDMI		18
+#define CLK_HDMI_DDC		19
+#define CLK_I2S0		20
+#define CLK_I2S1		21
+#define CLK_I2S2		22
+#define CLK_MMC0		23
+#define CLK_MMC0_SAMPLE		24
+#define CLK_MMC0_OUTPUT		25
+#define CLK_MMC1		26
+#define CLK_MMC1_SAMPLE		27
+#define CLK_MMC1_OUTPUT		28
+#define CLK_MMC2		29
+#define CLK_MMC2_SAMPLE		30
+#define CLK_MMC2_OUTPUT		31
+#define CLK_PLL_AUDIO		32
+#define CLK_PLL_DE		33
+#define CLK_PLL_GPU		34
+#define CLK_PLL_PERIPH0		35
+#define CLK_PLL_PERIPH1		36
+#define CLK_PLL_VE		37
+#define CLK_PLL_VIDEO		38
+#define CLK_SPDIF		39
+#define CLK_SPI0		40
+#define CLK_SPI1		41
+#define CLK_TCON0		42
+#define CLK_THS			43
+#define CLK_TVE			44
+#define CLK_USB_OHCI0		45
+#define CLK_USB_OHCI1		46
+#define CLK_USB_OHCI2		47
+#define CLK_USB_OHCI3		48
+#define CLK_USB_PHY0		49
+#define CLK_USB_PHY1		50
+#define CLK_USB_PHY2		51
+#define CLK_USB_PHY3		52
+#define CLK_VE			53
+
+#endif /* _DT_BINDINGS_CLK_SUN8I_H3_H_ */
diff --git a/include/dt-bindings/reset/sun8i-a83t.h b/include/dt-bindings/reset/sun8i-a83t.h
new file mode 100644
index 0000000..c64fa45
--- /dev/null
+++ b/include/dt-bindings/reset/sun8i-a83t.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Based on the H3 version from
+ * Copyright (C) 2016 Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DT_BINDINGS_RST_SUN8I_A83T_H_
+#define _DT_BINDINGS_RST_SUN8I_A83T_H_
+
+#define RST_USB_PHY0	0
+#define RST_USB_PHY1	1
+#define RST_USB_HSIC	2
+#define RST_DRAM_CTR	3
+#define RST_MBUS	4
+#define RST_MIPI_DSI	5
+#define RST_CE		6
+#define RST_DMA		7
+#define RST_NAND	8
+#define RST_DRAM	9
+#define RST_EMAC	10
+#define RST_HSTIMER	11
+#define RST_SPI0	12
+#define RST_SPI1	13
+#define RST_USBDRD	14
+#define RST_EHCI0	15
+#define RST_EHCI1	16
+#define RST_OHCI0	17
+#define RST_VE		18
+#define RST_CSI		19
+#define RST_HDMI0	20
+#define RST_HDMI1	21
+#define RST_GPU		22
+#define RST_MSGBOX	23
+#define RST_SPINLOCK	24
+#define RST_LVDS	25
+#define RST_SPDIF	26
+#define RST_DAUDIO0	27
+#define RST_DAUDIO1	28
+#define RST_DAUDIO2	29
+#define RST_TDM		30
+#define RST_I2C0	31
+#define RST_I2C1	32
+#define RST_I2C2	33
+#define RST_UART0	34
+#define RST_UART1	35
+#define RST_UART2	36
+#define RST_UART3	37
+#define RST_UART4	38
+
+#endif /* _DT_BINDINGS_RST_SUN8I_A83T_H_ */
diff --git a/include/dt-bindings/reset/sun8i-h3.h b/include/dt-bindings/reset/sun8i-h3.h
new file mode 100644
index 0000000..340ab7e
--- /dev/null
+++ b/include/dt-bindings/reset/sun8i-h3.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DT_BINDINGS_RST_SUN8I_H3_H_
+#define _DT_BINDINGS_RST_SUN8I_H3_H_
+
+#define RST_USB_PHY0	0
+#define RST_USB_PHY1	1
+#define RST_USB_PHY2	2
+#define RST_USB_PHY3	3
+#define RST_MBUS	4
+#define RST_CE		5
+#define RST_DMA		6
+#define RST_UART0	7
+#define RST_UART1	8
+#define RST_UART2	9
+#define RST_NAND	10
+#define RST_DRAM	11
+#define RST_EMAC	12
+#define RST_TS		13
+#define RST_HSTIMER	14
+#define RST_SPI0	15
+#define RST_SPI1	16
+#define RST_OTG		17
+#define RST_EHCI0	18
+#define RST_EHCI1	19
+#define RST_EHCI2	20
+#define RST_EHCI3	21
+#define RST_OHCI0	22
+#define RST_OHCI1	23
+#define RST_OHCI2	24
+#define RST_OHCI3	25
+#define RST_VE		26
+#define RST_DEINTERLACE	27
+#define RST_CSI		28
+#define RST_TVE		29
+#define RST_HDMI0	30
+#define RST_HDMI1	31
+#define RST_GPU		32
+#define RST_MSGBOX	33
+#define RST_SPINLOCK	34
+#define RST_DBG		35
+#define RST_EPHY	36
+#define RST_CODEC	37
+#define RST_SPDIF	38
+#define RST_THS		39
+#define RST_I2S0	40
+#define RST_I2S1	41
+#define RST_I2S2	42
+#define RST_I2C0	43
+#define RST_I2C1	44
+#define RST_I2C2	45
+#define RST_UART3	46
+#define RST_SCR		47
+
+#endif /* _DT_BINDINGS_RST_SUN8I_H3_H_ */
